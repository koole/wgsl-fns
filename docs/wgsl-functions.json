{
  "meta": {
    "generatedAt": "2025-07-17T11:15:36.237Z",
    "totalFunctions": 20,
    "totalCategories": 4
  },
  "categories": [
    {
      "name": "Math & Utility",
      "slug": "math---utility",
      "description": "Mathematical functions and general utilities for shader calculations.",
      "functions": [
        {
          "name": "elasticWave",
          "description": "an elastic wave with exponential decay and sinusoidal oscillation.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position along the wave."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude multiplier."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "decay",
              "type": "f32",
              "description": "Exponential decay factor."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset for the wave."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn elasticWave(x: f32, amplitude: f32, frequency: f32, decay: f32, phase: f32) -> f32 {\n  let d = max(0.001, decay);\n  let decayTerm = exp(-d * x);\n  let oscTerm = sin(frequency * x * 6.28318 + phase);\n  return amplitude * decayTerm * oscTerm;\n}"
        },
        {
          "name": "smoothStep",
          "description": "interpolation between two values with smooth acceleration and deceleration.",
          "params": [
            {
              "name": "edge0",
              "type": "f32",
              "description": "Lower edge of interpolation range."
            },
            {
              "name": "edge1",
              "type": "f32",
              "description": "Upper edge of interpolation range."
            },
            {
              "name": "x",
              "type": "f32",
              "description": "Input value to interpolate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "interpolated value between 0 and 1."
          },
          "wgslCode": "fn smoothStep(edge0: f32, edge1: f32, x: f32) -> f32 {\n  let t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  return t * t * (3.0 - 2.0 * t);\n}"
        },
        {
          "name": "rotate2D",
          "description": "a 2D vector by a given angle.",
          "params": [
            {
              "name": "v",
              "type": "vec2<f32>",
              "description": "Input 2D vector to rotate."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Rotation angle in radians."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "2D vector."
          },
          "wgslCode": "fn rotate2D(v: vec2<f32>, angle: f32) -> vec2<f32> {\n  let c = cos(angle);\n  let s = sin(angle);\n  return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}"
        },
        {
          "name": "exponentialRamp",
          "description": "an exponential ramp function with derivative.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "base",
              "type": "f32",
              "description": "Exponential base."
            },
            {
              "name": "scale",
              "type": "f32",
              "description": "Scale factor."
            },
            {
              "name": "offset",
              "type": "f32",
              "description": "Vertical offset."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative."
          },
          "wgslCode": "fn exponentialRamp(x: f32, base: f32, scale: f32, offset: f32) -> vec2<f32> {\n  // Ensure base is positive and not 1 (which would make it linear)\n  let b = select(base, 2.71828, abs(base - 1.0) < 0.001);\n  \n  // Calculate the exponential function\n  let result = scale * pow(b, x) + offset;\n  \n  // Calculate the derivative\n  let derivative = scale * pow(b, x) * log(b);\n  \n  return vec2<f32>(result, derivative);\n}"
        },
        {
          "name": "logisticCurve",
          "description": "a logistic (S-curve) function with derivative.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "midpoint",
              "type": "f32",
              "description": "Curve midpoint (inflection point)."
            },
            {
              "name": "steepness",
              "type": "f32",
              "description": "Curve steepness factor."
            },
            {
              "name": "min",
              "type": "f32",
              "description": "Minimum output value."
            },
            {
              "name": "max",
              "type": "f32",
              "description": "Maximum output value."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative."
          },
          "wgslCode": "fn logisticCurve(x: f32, midpoint: f32, steepness: f32, min: f32, max: f32) -> vec2<f32> {\n  // Scale factor for steepness\n  let k = max(0.001, steepness);\n  \n  // Shift x relative to midpoint\n  let z = -k * (x - midpoint);\n  \n  // Calculate the exponent\n  let expTerm = exp(z);\n  \n  // Calculate the logistic function value\n  let logistic = 1.0 / (1.0 + expTerm);\n  \n  // Scale to min-max range\n  let range = max - min;\n  let value = min + range * logistic;\n  \n  // Calculate the derivative\n  let derivative = range * k * expTerm / ((1.0 + expTerm) * (1.0 + expTerm));\n  \n  return vec2<f32>(value, derivative);\n}"
        },
        {
          "name": "stepSequence",
          "description": "a stepped sequence with optional smoothing between steps.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "steps",
              "type": "f32",
              "description": "Number of steps in the sequence."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor between steps (0-1)."
            },
            {
              "name": "minValue",
              "type": "f32",
              "description": "Minimum output value."
            },
            {
              "name": "maxValue",
              "type": "f32",
              "description": "Maximum output value."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and current step index."
          },
          "wgslCode": "fn stepSequence(x: f32, steps: f32, smoothing: f32, minValue: f32, maxValue: f32) -> vec2<f32> {\n  // Ensure at least 1 step and positive smoothing\n  let numSteps = max(1.0, floor(steps));\n  let smoothFactor = max(0.0, smoothing);\n  \n  // Normalize x to 0-1 range\n  let normalizedX = fract(x);\n  \n  // Calculate the size of each step\n  let stepSize = 1.0 / numSteps;\n  \n  // Calculate the current step (0 to numSteps-1)\n  let currentStep = floor(normalizedX * numSteps);\n  let nextStep = fract(currentStep + 1.0);\n  \n  // Calculate progress within the current step\n  let stepProgress = fract(normalizedX * numSteps);\n  \n  // Calculate the progress values for current and next steps\n  let currentStepValue = currentStep / (numSteps - 1.0);\n  \n  // Prepare next step value, handle the last step case\n  var nextStepValue: f32 = 0.0;\n  if (currentStep >= numSteps - 1.0) {\n    nextStepValue = 1.0;\n  } else {\n    nextStepValue = nextStep / (numSteps - 1.0);\n  }\n  \n  // Apply smoothing between steps if needed\n  var result: f32 = 0.0;\n  \n  if (smoothFactor > 0.0 && stepProgress > (1.0 - smoothFactor) && numSteps > 1.0) {\n    // Calculate smoothing factor\n    let t = (stepProgress - (1.0 - smoothFactor)) / smoothFactor;\n    \n    // Smoothstep for better transition\n    let smoothT = t * t * (3.0 - 2.0 * t);\n    \n    // Interpolate between current and next step\n    result = mix(currentStepValue, nextStepValue, smoothT);\n  } else {\n    result = currentStepValue;\n  }\n  \n  // Scale to min-max range\n  let range = maxValue - minValue;\n  let finalResult = minValue + result * range;\n  \n  return vec2<f32>(finalResult, currentStep);\n}"
        }
      ]
    },
    {
      "name": "Noise & Procedural",
      "slug": "noise---procedural",
      "description": "Noise generation and procedural pattern functions for textures and effects.",
      "functions": [
        {
          "name": "hash22",
          "description": "a 2D hash from a 2D input vector for procedural generation.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D vector to hash."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "result as 2D vector."
          },
          "wgslCode": "fn hash22(p: vec2<f32>) -> vec2<f32> {\n  var p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}"
        },
        {
          "name": "noise2D",
          "description": "2D Perlin-style noise for procedural textures and patterns.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value typically in range [-1, 1]."
          },
          "wgslCode": "fn noise2D(p: vec2<f32>) -> f32 {\n  let i = floor(p);\n  let f = fract(p);\n  let u = f * f * (3.0 - 2.0 * f);\n  return mix(\n    mix(dot(hash22(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n        dot(hash22(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n    mix(dot(hash22(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n        dot(hash22(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}"
        },
        {
          "name": "fbm",
          "description": "Brownian Motion - combines multiple octaves of noise for complex patterns.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            },
            {
              "name": "octaves",
              "type": "i32",
              "description": "Number of noise octaves to combine."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value."
          },
          "wgslCode": "fn fbm(p: vec2<f32>, octaves: i32) -> f32 {\n  var value = 0.0;\n  var amplitude = 0.5;\n  var frequency = 1.0;\n  for (var i = 0; i < octaves; i++) {\n    value += amplitude * noise2D(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}"
        },
        {
          "name": "hash1D",
          "description": "a 1D hash value from an input value for noise generation.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "Input value to hash."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "wgslCode": "fn hash1D(p: f32) -> f32 {\n  // Convert to integer and apply bit manipulation\n  let x = bitcast<u32>(p + 123.456789);\n  var h = x;\n  \n  // Wang hash function\n  h = (h ^ 61u) ^ (h >> 16u);\n  h = h + (h << 3u);\n  h = h ^ (h >> 4u);\n  h = h * 0x27d4eb2du;\n  h = h ^ (h >> 15u);\n  \n  // Convert back to float and normalize\n  return f32(h) / 4294967296.0;\n}"
        }
      ]
    },
    {
      "name": "Signed Distance Fields",
      "slug": "signed-distance-fields",
      "description": "SDF functions for procedural geometry and ray marching techniques.",
      "functions": [
        {
          "name": "sdfCircle",
          "description": "distance function for a circle.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Point to evaluate distance from."
            },
            {
              "name": "r",
              "type": "f32",
              "description": "Circle radius."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to circle surface (negative inside, positive outside)."
          },
          "wgslCode": "fn sdfCircle(p: vec2<f32>, r: f32) -> f32 {\n  return length(p) - r;\n}"
        },
        {
          "name": "sdfBox",
          "description": "distance function for a rectangular box.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Point to evaluate distance from."
            },
            {
              "name": "b",
              "type": "vec2<f32>",
              "description": "Box half-dimensions (width/2, height/2)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to box surface (negative inside, positive outside)."
          },
          "wgslCode": "fn sdfBox(p: vec2<f32>, b: vec2<f32>) -> f32 {\n  let d = abs(p) - b;\n  return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n}"
        },
        {
          "name": "sdfUnion",
          "description": "two SDFs using union operation (closest surface).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from first shape."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from second shape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing union of both shapes."
          },
          "wgslCode": "fn sdfUnion(d1: f32, d2: f32) -> f32 {\n  return min(d1, d2);\n}"
        },
        {
          "name": "sdfIntersection",
          "description": "two SDFs using intersection operation (overlapping area only).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from first shape."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from second shape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing intersection of both shapes."
          },
          "wgslCode": "fn sdfIntersection(d1: f32, d2: f32) -> f32 {\n  return max(d1, d2);\n}"
        },
        {
          "name": "sdfSubtraction",
          "description": "two SDFs using subtraction operation (first shape minus second).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from shape to subtract from."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from shape to subtract."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing first shape with second subtracted."
          },
          "wgslCode": "fn sdfSubtraction(d1: f32, d2: f32) -> f32 {\n  return max(-d1, d2);\n}"
        }
      ]
    },
    {
      "name": "Color & Graphics",
      "slug": "color---graphics",
      "description": "Color space conversion and palette generation functions.",
      "functions": [
        {
          "name": "palette",
          "description": "colors using cosine-based palette function for smooth color gradients.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (typically 0-1) for palette lookup."
            },
            {
              "name": "a",
              "type": "vec3<f32>",
              "description": "Offset values for RGB channels."
            },
            {
              "name": "b",
              "type": "vec3<f32>",
              "description": "Amplitude values for RGB channels."
            },
            {
              "name": "c",
              "type": "vec3<f32>",
              "description": "Frequency values for RGB channels."
            },
            {
              "name": "d",
              "type": "vec3<f32>",
              "description": "Phase values for RGB channels."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "RGB color."
          },
          "wgslCode": "fn palette(t: f32, a: vec3<f32>, b: vec3<f32>, c: vec3<f32>, d: vec3<f32>) -> vec3<f32> {\n  return a + b * cos(6.28318 * (c * t + d));\n}"
        },
        {
          "name": "linearToSrgb",
          "description": "linear RGB color values to sRGB color space.",
          "params": [
            {
              "name": "color",
              "type": "vec3<f32>",
              "description": "Linear RGB color values."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "color values."
          },
          "wgslCode": "fn linearToSrgb(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3(1.0 / 2.2));\n}"
        },
        {
          "name": "srgbToLinear",
          "description": "sRGB color values to linear RGB color space.",
          "params": [
            {
              "name": "color",
              "type": "vec3<f32>",
              "description": "sRGB color values."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "RGB color values."
          },
          "wgslCode": "fn srgbToLinear(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3(2.2));\n}"
        },
        {
          "name": "hue2rgb",
          "description": "function for HSL to RGB conversion - converts hue component to RGB.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "First HSL conversion parameter."
            },
            {
              "name": "q",
              "type": "f32",
              "description": "Second HSL conversion parameter."
            },
            {
              "name": "t",
              "type": "f32",
              "description": "Hue value (adjusted)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "component value."
          },
          "wgslCode": "fn hue2rgb(p: f32, q: f32, t: f32) -> f32 {\n  var t_adj = t;\n  if (t_adj < 0.0) { t_adj += 1.0; }\n  if (t_adj > 1.0) { t_adj -= 1.0; }\n  if (t_adj < 1.0 / 6.0) { return p + (q - p) * 6.0 * t_adj; }\n  if (t_adj < 1.0 / 2.0) { return q; }\n  if (t_adj < 2.0 / 3.0) { return p + (q - p) * (2.0 / 3.0 - t_adj) * 6.0; }\n  return p;\n}"
        },
        {
          "name": "hslToRgb",
          "description": "HSL (Hue, Saturation, Lightness) color to RGB.",
          "params": [
            {
              "name": "hsl",
              "type": "vec3<f32>",
              "description": "HSL color values (hue: 0-1, saturation: 0-1, lightness: 0-1)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "color values."
          },
          "wgslCode": "fn hslToRgb(hsl: vec3<f32>) -> vec3<f32> {\n  let h = hsl.x;\n  let s = hsl.y;\n  let l = hsl.z;\n  \n  if (s == 0.0) {\n    return vec3(l); // achromatic\n  }\n  \n  let q = select(l * (1.0 + s), l + s - l * s, l < 0.5);\n  let p = 2.0 * l - q;\n  \n  return vec3(\n    hue2rgb(p, q, h + 1.0 / 3.0),\n    hue2rgb(p, q, h),\n    hue2rgb(p, q, h - 1.0 / 3.0)\n  );\n}"
        }
      ]
    }
  ]
}