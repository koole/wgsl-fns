{
  "meta": {
    "generatedAt": "2025-07-21T22:01:56.385Z",
    "totalFunctions": 109,
    "totalCategories": 10
  },
  "categories": [
    {
      "name": "Math & Utility",
      "slug": "math---utility",
      "description": "Mathematical functions and general utilities for shader calculations.",
      "functions": [
        {
          "name": "elasticWave",
          "description": "an elastic wave with exponential decay and sinusoidal oscillation.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position along the wave."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude multiplier."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "decay",
              "type": "f32",
              "description": "Exponential decay factor."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset for the wave."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "dependencies": [],
          "wgslCode": "fn elasticWave(x: f32, amplitude: f32, frequency: f32, decay: f32, phase: f32) -> f32 {\n  let d = max(0.001, decay);\n  let decayTerm = exp(-d * x);\n  let oscTerm = sin(frequency * x * 6.28318 + phase);\n  return amplitude * decayTerm * oscTerm;\n}"
        },
        {
          "name": "smoothStep",
          "description": "interpolation between two values with smooth acceleration and deceleration.",
          "params": [
            {
              "name": "edge0",
              "type": "f32",
              "description": "Lower edge of interpolation range."
            },
            {
              "name": "edge1",
              "type": "f32",
              "description": "Upper edge of interpolation range."
            },
            {
              "name": "x",
              "type": "f32",
              "description": "Input value to interpolate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "interpolated value between 0 and 1."
          },
          "dependencies": [],
          "wgslCode": "fn smoothStep(edge0: f32, edge1: f32, x: f32) -> f32 {\n  let t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  return t * t * (3.0 - 2.0 * t);\n}"
        },
        {
          "name": "smoothStepVec2",
          "description": "interpolation between two vectors with smooth acceleration and deceleration.",
          "params": [
            {
              "name": "edge0",
              "type": "vec2<f32>",
              "description": "Lower edge of interpolation range."
            },
            {
              "name": "edge1",
              "type": "vec2<f32>",
              "description": "Upper edge of interpolation range."
            },
            {
              "name": "x",
              "type": "vec2<f32>",
              "description": "Input vector to interpolate."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "interpolated vector between 0 and 1."
          },
          "dependencies": [],
          "wgslCode": "fn smoothStepVec2(edge0: vec2f, edge1: vec2f, x: vec2f) -> vec2f {\n  let t = clamp((x - edge0) / (edge1 - edge0), vec2f(0.0), vec2f(1.0));\n  return t * t * (3.0 - 2.0 * t);\n}"
        },
        {
          "name": "rotate2D",
          "description": "a 2D vector by a given angle.",
          "params": [
            {
              "name": "v",
              "type": "vec2<f32>",
              "description": "Input 2D vector to rotate."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Rotation angle in radians."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "2D vector."
          },
          "dependencies": [],
          "wgslCode": "fn rotate2D(v: vec2<f32>, angle: f32) -> vec2<f32> {\n  let c = cos(angle);\n  let s = sin(angle);\n  return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}"
        },
        {
          "name": "exponentialRamp",
          "description": "an exponential ramp function with derivative.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "base",
              "type": "f32",
              "description": "Exponential base."
            },
            {
              "name": "scale",
              "type": "f32",
              "description": "Scale factor."
            },
            {
              "name": "offset",
              "type": "f32",
              "description": "Vertical offset."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative."
          },
          "dependencies": [],
          "wgslCode": "fn exponentialRamp(x: f32, base: f32, scale: f32, offset: f32) -> vec2<f32> {\n  // Ensure base is positive and not 1 (which would make it linear)\n  let b = select(base, 2.71828, abs(base - 1.0) < 0.001);\n  \n  // Calculate the exponential function\n  let result = scale * pow(b, x) + offset;\n  \n  // Calculate the derivative\n  let derivative = scale * pow(b, x) * log(b);\n  \n  return vec2<f32>(result, derivative);\n}"
        },
        {
          "name": "logisticCurve",
          "description": "a logistic (S-curve) function with derivative.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "midpoint",
              "type": "f32",
              "description": "Curve midpoint (inflection point)."
            },
            {
              "name": "steepness",
              "type": "f32",
              "description": "Curve steepness factor."
            },
            {
              "name": "min",
              "type": "f32",
              "description": "Minimum output value."
            },
            {
              "name": "max",
              "type": "f32",
              "description": "Maximum output value."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative."
          },
          "dependencies": [],
          "wgslCode": "fn logisticCurve(x: f32, midpoint: f32, steepness: f32, minValue: f32, maxValue: f32) -> vec2<f32> {\n  // Scale factor for steepness\n  let k = max(0.001, steepness);\n  \n  // Shift x relative to midpoint\n  let z = -k * (x - midpoint);\n  \n  // Calculate the exponent\n  let expTerm = exp(z);\n  \n  // Calculate the logistic function value\n  let logistic = 1.0 / (1.0 + expTerm);\n  \n  // Scale to min-max range\n  let range = maxValue - minValue;\n  let value = minValue + range * logistic;\n  \n  // Calculate the derivative\n  let derivative = range * k * expTerm / ((1.0 + expTerm) * (1.0 + expTerm));\n  \n  return vec2<f32>(value, derivative);\n}"
        },
        {
          "name": "stepSequence",
          "description": "a stepped sequence with optional smoothing between steps.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "steps",
              "type": "f32",
              "description": "Number of steps in the sequence."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor between steps (0-1)."
            },
            {
              "name": "minValue",
              "type": "f32",
              "description": "Minimum output value."
            },
            {
              "name": "maxValue",
              "type": "f32",
              "description": "Maximum output value."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and current step index."
          },
          "dependencies": [],
          "wgslCode": "fn stepSequence(x: f32, steps: f32, smoothing: f32, minValue: f32, maxValue: f32) -> vec2<f32> {\n  // Ensure at least 1 step and positive smoothing\n  let numSteps = max(1.0, floor(steps));\n  let smoothFactor = max(0.0, smoothing);\n  \n  // Normalize x to 0-1 range\n  let normalizedX = fract(x);\n  \n  // Calculate the size of each step\n  let stepSize = 1.0 / numSteps;\n  \n  // Calculate the current step (0 to numSteps-1)\n  let currentStep = floor(normalizedX * numSteps);\n  let nextStep = fract(currentStep + 1.0);\n  \n  // Calculate progress within the current step\n  let stepProgress = fract(normalizedX * numSteps);\n  \n  // Calculate the progress values for current and next steps\n  let currentStepValue = currentStep / (numSteps - 1.0);\n  \n  // Prepare next step value, handle the last step case\n  var nextStepValue: f32 = 0.0;\n  if (currentStep >= numSteps - 1.0) {\n    nextStepValue = 1.0;\n  } else {\n    nextStepValue = nextStep / (numSteps - 1.0);\n  }\n  \n  // Apply smoothing between steps if needed\n  var result: f32 = 0.0;\n  \n  if (smoothFactor > 0.0 && stepProgress > (1.0 - smoothFactor) && numSteps > 1.0) {\n    // Calculate smoothing factor\n    let t = (stepProgress - (1.0 - smoothFactor)) / smoothFactor;\n    \n    // Smoothstep for better transition\n    let smoothT = t * t * (3.0 - 2.0 * t);\n    \n    // Interpolate between current and next step\n    result = mix(currentStepValue, nextStepValue, smoothT);\n  } else {\n    result = currentStepValue;\n  }\n  \n  // Scale to min-max range\n  let range = maxValue - minValue;\n  let finalResult = minValue + result * range;\n  \n  return vec2<f32>(finalResult, currentStep);\n}"
        },
        {
          "name": "taylorInvSqrt4",
          "description": "series inverse square root approximation for Perlin noise.",
          "params": [
            {
              "name": "r",
              "type": "vec4<f32>",
              "description": "Input 4D vector."
            }
          ],
          "returns": {
            "type": "vec4<f32>",
            "description": "square root approximation."
          },
          "dependencies": [],
          "wgslCode": "fn taylorInvSqrt4(r: vec4f) -> vec4f { \n    return 1.79284291400159 - 0.85373472095314 * r; \n}"
        }
      ]
    },
    {
      "name": "Noise & Procedural",
      "slug": "noise---procedural",
      "description": "Noise generation and procedural pattern functions for textures and effects.",
      "functions": [
        {
          "name": "hash22",
          "description": "a 2D hash from a 2D input vector for procedural generation.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D vector to hash."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "result as 2D vector."
          },
          "dependencies": [],
          "wgslCode": "fn hash22(p: vec2<f32>) -> vec2<f32> {\n  var p3 = fract(vec3<f32>(p.xyx) * vec3<f32>(0.1031, 0.1030, 0.0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}"
        },
        {
          "name": "noise2D",
          "description": "2D Perlin-style noise for procedural textures and patterns.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value typically in range [-1, 1]."
          },
          "dependencies": [
            "hash22"
          ],
          "wgslCode": "//! requires hash22\nfn noise2D(p: vec2<f32>) -> f32 {\n  let i = floor(p);\n  let f = fract(p);\n  let u = f * f * (3.0 - 2.0 * f);\n  return mix(\n    mix(dot(hash22(i + vec2<f32>(0.0, 0.0)), f - vec2<f32>(0.0, 0.0)),\n        dot(hash22(i + vec2<f32>(1.0, 0.0)), f - vec2<f32>(1.0, 0.0)), u.x),\n    mix(dot(hash22(i + vec2<f32>(0.0, 1.0)), f - vec2<f32>(0.0, 1.0)),\n        dot(hash22(i + vec2<f32>(1.0, 1.0)), f - vec2<f32>(1.0, 1.0)), u.x), u.y);\n}"
        },
        {
          "name": "fbm",
          "description": "Brownian Motion - combines multiple octaves of noise for complex patterns.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            },
            {
              "name": "octaves",
              "type": "i32",
              "description": "Number of noise octaves to combine."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value."
          },
          "dependencies": [
            "noise2D"
          ],
          "wgslCode": "//! requires noise2D\nfn fbm(p: vec2<f32>, octaves: i32) -> f32 {\n  var value = 0.0;\n  var amplitude = 0.5;\n  var frequency = 1.0;\n  for (var i = 0; i < octaves; i++) {\n    value += amplitude * noise2D(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}"
        },
        {
          "name": "hash1D",
          "description": "a 1D hash value from an input value for noise generation.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "Input value to hash."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "dependencies": [],
          "wgslCode": "fn hash1D(p: f32) -> f32 {\n  // Convert to integer and apply bit manipulation\n  let x = bitcast<u32>(p + 123.456789);\n  var h = x;\n  \n  // Wang hash function\n  h = (h ^ 61u) ^ (h >> 16u);\n  h = h + (h << 3u);\n  h = h ^ (h >> 4u);\n  h = h * 0x27d4eb2du;\n  h = h ^ (h >> 15u);\n  \n  // Convert back to float and normalize\n  return f32(h) / 4294967296.0;\n}"
        },
        {
          "name": "hash31",
          "description": "a 1D hash value from a 3D input vector.",
          "params": [
            {
              "name": "p",
              "type": "vec3<f32>",
              "description": "Input 3D vector to hash."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "dependencies": [],
          "wgslCode": "fn hash31(p: vec3<f32>) -> f32 {\n  var p3 = fract(p * vec3<f32>(0.1031, 0.1030, 0.0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}"
        },
        {
          "name": "hash3D",
          "description": "a 3D hash vector from a 3D input for displacement effects.",
          "params": [
            {
              "name": "p",
              "type": "vec3<f32>",
              "description": "Input 3D vector to hash."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "result as 3D vector with values between -1 and 1."
          },
          "dependencies": [],
          "wgslCode": "fn hash3D(p: vec3<f32>) -> vec3<f32> {\n  var p3 = fract(p * vec3<f32>(0.1031, 0.1030, 0.0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx) * p3.zyx) * 2.0 - 1.0;\n}"
        },
        {
          "name": "noise3D",
          "description": "3D noise using trilinear interpolation.",
          "params": [
            {
              "name": "x",
              "type": "vec3<f32>",
              "description": "Input 3D position for noise generation."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "dependencies": [
            "hash31"
          ],
          "wgslCode": "//! requires hash31\nfn noise3D(x: vec3<f32>) -> f32 {\n  let p = floor(x);\n  let f = fract(x);\n  \n  return mix(\n    mix(\n      mix(hash31(p), \n          hash31(p + vec3<f32>(1.0, 0.0, 0.0)), \n          f.x),\n      mix(hash31(p + vec3<f32>(0.0, 1.0, 0.0)), \n          hash31(p + vec3<f32>(1.0, 1.0, 0.0)), \n          f.x),\n      f.y),\n    mix(\n      mix(hash31(p + vec3<f32>(0.0, 0.0, 1.0)), \n          hash31(p + vec3<f32>(1.0, 0.0, 1.0)), \n          f.x),\n      mix(hash31(p + vec3<f32>(0.0, 1.0, 1.0)), \n          hash31(p + vec3<f32>(1.0, 1.0, 1.0)), \n          f.x),\n      f.y),\n    f.z);\n}"
        },
        {
          "name": "warpNoise3D",
          "description": "3D warping noise using fractal Brownian motion.",
          "params": [
            {
              "name": "x",
              "type": "vec3<f32>",
              "description": "Input 3D position."
            },
            {
              "name": "seedVal",
              "type": "f32",
              "description": "Random seed for variation."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "warp vector with values between -1 and 1."
          },
          "dependencies": [
            "noise3D"
          ],
          "wgslCode": "//! requires noise3D\nfn warpNoise3D(x: vec3<f32>, seedVal: f32) -> vec3<f32> {\n  var p = x + seedVal;\n  var nx = 0.0;\n  var ny = 0.0;\n  var nz = 0.0;\n  var w = 0.5;\n  \n  for (var i = 0; i < 3; i++) {\n    nx += w * noise3D(p);\n    ny += w * noise3D(p + vec3<f32>(13.5, 41.3, 17.8));\n    nz += w * noise3D(p + vec3<f32>(31.2, 23.7, 11.9));\n    p *= 2.0;\n    w *= 0.5;\n  }\n  \n  return vec3<f32>(nx, ny, nz) * 2.0 - 1.0;\n}"
        },
        {
          "name": "pcg",
          "description": "and fast integer hash using PCG algorithm.",
          "params": [
            {
              "name": "n",
              "type": "u32",
              "description": "Input unsigned integer to hash."
            }
          ],
          "returns": {
            "type": "u32",
            "description": "unsigned integer value."
          },
          "dependencies": [],
          "wgslCode": "fn pcg(n: u32) -> u32 {\n    var h = n * 747796405u + 2891336453u;\n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    return (h >> 22u) ^ h;\n}"
        },
        {
          "name": "pcg2d",
          "description": "PCG hash function for fast procedural generation.",
          "params": [
            {
              "name": "p",
              "type": "vec2<u32>",
              "description": "Input 2D unsigned integer vector to hash."
            }
          ],
          "returns": {
            "type": "vec2<u32>",
            "description": "2D unsigned integer vector."
          },
          "dependencies": [],
          "wgslCode": "fn pcg2d(p: vec2u) -> vec2u {\n    var v = p * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u; v.y += v.x * 1664525u;\n    v ^= v >> vec2u(16u);\n    v.x += v.y * 1664525u; v.y += v.x * 1664525u;\n    v ^= v >> vec2u(16u);\n    return v;\n}"
        },
        {
          "name": "pcg3d",
          "description": "PCG hash function for volumetric procedural generation.",
          "params": [
            {
              "name": "p",
              "type": "vec3<u32>",
              "description": "Input 3D unsigned integer vector to hash."
            }
          ],
          "returns": {
            "type": "vec3<u32>",
            "description": "3D unsigned integer vector."
          },
          "dependencies": [],
          "wgslCode": "fn pcg3d(p: vec3u) -> vec3u {\n    var v = p * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v ^= v >> vec3u(16u);\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return v;\n}"
        },
        {
          "name": "pcg4d",
          "description": "PCG hash function for advanced procedural generation.",
          "params": [
            {
              "name": "p",
              "type": "vec4<u32>",
              "description": "Input 4D unsigned integer vector to hash."
            }
          ],
          "returns": {
            "type": "vec4<u32>",
            "description": "4D unsigned integer vector."
          },
          "dependencies": [],
          "wgslCode": "fn pcg4d(p: vec4u) -> vec4u {\n    var v = p * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v ^= v >> vec4u(16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}"
        },
        {
          "name": "xxhash32",
          "description": "integer hash using xxHash algorithm.",
          "params": [
            {
              "name": "n",
              "type": "u32",
              "description": "Input unsigned integer to hash."
            }
          ],
          "returns": {
            "type": "u32",
            "description": "unsigned integer value."
          },
          "dependencies": [],
          "wgslCode": "fn xxhash32(n: u32) -> u32 {\n    var h32 = n + 374761393u;\n    h32 = 668265263u * ((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = 2246822519u * (h32 ^ (h32 >> 15));\n    h32 = 3266489917u * (h32 ^ (h32 >> 13));\n    return h32^(h32 >> 16);\n}"
        },
        {
          "name": "xxhash322d",
          "description": "xxHash for strong integer hashing in 2D.",
          "params": [
            {
              "name": "p",
              "type": "vec2<u32>",
              "description": "Input 2D unsigned integer vector to hash."
            }
          ],
          "returns": {
            "type": "u32",
            "description": "unsigned integer value."
          },
          "dependencies": [],
          "wgslCode": "fn xxhash322d(p: vec2u) -> u32 {\n    let p2 = 2246822519u; let p3 = 3266489917u;\n    let p4 = 668265263u; let p5 = 374761393u;\n    var h32 = p.y + p5 + p.x * p3;\n    h32 = p4 * ((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = p2 * (h32^(h32 >> 15));\n    h32 = p3 * (h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}"
        },
        {
          "name": "xxhash323d",
          "description": "xxHash for strong integer hashing in 3D.",
          "params": [
            {
              "name": "p",
              "type": "vec3<u32>",
              "description": "Input 3D unsigned integer vector to hash."
            }
          ],
          "returns": {
            "type": "u32",
            "description": "unsigned integer value."
          },
          "dependencies": [],
          "wgslCode": "fn xxhash323d(p: vec3u) -> u32 {\n    let p2 = 2246822519u; let p3 = 3266489917u;\n    let p4 = 668265263u; let p5 = 374761393u;\n    var h32 =  p.z + p5 + p.x*p3;\n    h32 = p4 * ((h32 << 17) | (h32 >> (32 - 17)));\n    h32 += p.y * p3;\n    h32 = p4 * ((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = p2 * (h32^(h32 >> 15));\n    h32 = p3 * (h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}"
        },
        {
          "name": "xxhash324d",
          "description": "xxHash for strong integer hashing in 4D.",
          "params": [
            {
              "name": "p",
              "type": "vec4<u32>",
              "description": "Input 4D unsigned integer vector to hash."
            }
          ],
          "returns": {
            "type": "u32",
            "description": "unsigned integer value."
          },
          "dependencies": [],
          "wgslCode": "fn xxhash324d(p: vec4u) -> u32 {\n    let p2 = 2246822519u; let p3 = 3266489917u;\n    let p4 = 668265263u; let p5 = 374761393u;\n    var h32 = p.w + p5 + p.x * p3;\n    h32 = p4 * ((h32 << 17) | (h32 >> (32 - 17)));\n    h32 += p.y * p3;\n    h32 = p4 * ((h32 << 17) | (h32 >> (32 - 17)));\n    h32 += p.z  * p3;\n    h32 = p4 * ((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = p2 * (h32^(h32 >> 15));\n    h32 = p3 * (h32^(h32 >> 13));\n    return h32 ^ (h32 >> 16);\n}"
        },
        {
          "name": "rand11Sin",
          "description": "float from 1D input using sine (platform dependent).",
          "params": [
            {
              "name": "n",
              "type": "f32",
              "description": "Input float value."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "float between 0 and 1."
          },
          "dependencies": [],
          "wgslCode": "fn rand11(n: f32) -> f32 { \n    return fract(sin(n) * 43758.5453123); \n}"
        },
        {
          "name": "rand22Sin",
          "description": "float from 2D input using sine (platform dependent).",
          "params": [
            {
              "name": "n",
              "type": "vec2<f32>",
              "description": "Input 2D vector."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "float between 0 and 1."
          },
          "dependencies": [],
          "wgslCode": "fn rand22(n: vec2f) -> f32 { \n    return fract(sin(dot(n, vec2f(12.9898, 4.1414))) * 43758.5453); \n}"
        },
        {
          "name": "valueNoise1D",
          "description": "1D value noise using random interpolation.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "Input 1D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "dependencies": [
            "rand11Sin"
          ],
          "wgslCode": "//! requires rand11Sin\nfn noise(p: f32) -> f32 {\n    let fl = floor(p);\n    return mix(rand11(fl), rand11(fl + 1.), fract(p));\n}"
        },
        {
          "name": "valueNoise2D",
          "description": "2D value noise using smooth interpolation.",
          "params": [
            {
              "name": "n",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "dependencies": [
            "rand22Sin",
            "smoothStepVec2"
          ],
          "wgslCode": "//! requires rand22Sin smoothStepVec2\nfn noise2(n: vec2f) -> f32 {\n    let d = vec2f(0., 1.);\n    let b = floor(n);\n    let f = smoothStepVec2(vec2f(0.), vec2f(1.), fract(n));\n    return mix(mix(rand22(b), rand22(b + d.yx), f.x), mix(rand22(b + d.xy), rand22(b + d.yy), f.x), f.y);\n}"
        },
        {
          "name": "mod289",
          "description": "289 operation for Perlin noise.",
          "params": [
            {
              "name": "x",
              "type": "vec4<f32>",
              "description": "Input 4D vector."
            }
          ],
          "returns": {
            "type": "vec4<f32>",
            "description": "of x mod 289."
          },
          "dependencies": [],
          "wgslCode": "fn mod289(x: vec4f) -> vec4f { \n    return x - floor(x * (1. / 289.)) * 289.; \n}"
        },
        {
          "name": "perm4",
          "description": "function for Perlin noise.",
          "params": [
            {
              "name": "x",
              "type": "vec4<f32>",
              "description": "Input 4D vector."
            }
          ],
          "returns": {
            "type": "vec4<f32>",
            "description": "4D vector."
          },
          "dependencies": [
            "mod289"
          ],
          "wgslCode": "//! requires mod289\nfn perm4(x: vec4f) -> vec4f { \n    return mod289(((x * 34.) + 1.) * x); \n}"
        },
        {
          "name": "valueNoise3D",
          "description": "value noise using permutation tables.",
          "params": [
            {
              "name": "p",
              "type": "vec3<f32>",
              "description": "Input 3D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "dependencies": [
            "perm4"
          ],
          "wgslCode": "//! requires perm4\nfn noise3(p: vec3f) -> f32 {\n    let a = floor(p);\n    var d: vec3f = p - a;\n    d = d * d * (3. - 2. * d);\n\n    let b = a.xxyy + vec4f(0., 1., 0., 1.);\n    let k1 = perm4(b.xyxy);\n    let k2 = perm4(k1.xyxy + b.zzww);\n\n    let c = k2 + a.zzzz;\n    let k3 = perm4(c);\n    let k4 = perm4(c + 1.);\n\n    let o1 = fract(k3 * (1. / 41.));\n    let o2 = fract(k4 * (1. / 41.));\n\n    let o3 = o2 * d.z + o1 * (1. - d.z);\n    let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n    return o4.y * d.y + o4.x * (1. - d.y);\n}"
        },
        {
          "name": "perlinNoise2D",
          "description": "Perlin noise implementation.",
          "params": [
            {
              "name": "P",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value."
          },
          "dependencies": [],
          "wgslCode": "fn perlinNoise2_permute4(x: vec4f) -> vec4f { \n    return ((x * 34. + 1.) * x) % vec4f(289.); \n}\n\nfn perlinNoise2_fade2(t: vec2f) -> vec2f { \n    return t * t * t * (t * (t * 6. - 15.) + 10.); \n}\n\nfn perlinNoise2(P: vec2f) -> f32 {\n    var Pi: vec4f = floor(P.xyxy) + vec4f(0., 0., 1., 1.);\n    let Pf = fract(P.xyxy) - vec4f(0., 0., 1., 1.);\n    Pi = Pi % vec4f(289.); // To avoid truncation effects in permutation\n    let ix = Pi.xzxz;\n    let iy = Pi.yyww;\n    let fx = Pf.xzxz;\n    let fy = Pf.yyww;\n    let i = perlinNoise2_permute4(perlinNoise2_permute4(ix) + iy);\n    var gx: vec4f = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...\n    let gy = abs(gx) - 0.5;\n    let tx = floor(gx + 0.5);\n    gx = gx - tx;\n    var g00: vec2f = vec2f(gx.x, gy.x);\n    var g10: vec2f = vec2f(gx.y, gy.y);\n    var g01: vec2f = vec2f(gx.z, gy.z);\n    var g11: vec2f = vec2f(gx.w, gy.w);\n    let norm = 1.79284291400159 - 0.85373472095314 *\n        vec4f(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 = g00 * norm.x;\n    g01 = g01 * norm.y;\n    g10 = g10 * norm.z;\n    g11 = g11 * norm.w;\n    let n00 = dot(g00, vec2f(fx.x, fy.x));\n    let n10 = dot(g10, vec2f(fx.y, fy.y));\n    let n01 = dot(g01, vec2f(fx.z, fy.z));\n    let n11 = dot(g11, vec2f(fx.w, fy.w));\n    let fade_xy = perlinNoise2_fade2(Pf.xy);\n    let n_x = mix(vec2f(n00, n01), vec2f(n10, n11), vec2f(fade_xy.x));\n    let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}"
        },
        {
          "name": "perlinNoise3D",
          "description": "Perlin noise implementation.",
          "params": [
            {
              "name": "P",
              "type": "vec3<f32>",
              "description": "Input 3D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value."
          },
          "dependencies": [
            "taylorInvSqrt4"
          ],
          "wgslCode": "//! requires taylorInvSqrt4\nfn perlinNoise3_permute4(x: vec4f) -> vec4f { \n    return ((x * 34. + 1.) * x) % vec4f(289.); \n}\n\nfn perlinNoise3_fade3(t: vec3f) -> vec3f { \n    return t * t * t * (t * (t * 6. - 15.) + 10.); \n}\n\nfn perlinNoise3(P: vec3f) -> f32 {\n    var Pi0 : vec3f = floor(P); // Integer part for indexing\n    var Pi1 : vec3f = Pi0 + vec3f(1.); // Integer part + 1\n    Pi0 = Pi0 % vec3f(289.);\n    Pi1 = Pi1 % vec3f(289.);\n    let Pf0 = fract(P); // Fractional part for interpolation\n    let Pf1 = Pf0 - vec3f(1.); // Fractional part - 1.\n    let ix = vec4f(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy = vec4f(Pi0.yy, Pi1.yy);\n    let iz0 = Pi0.zzzz;\n    let iz1 = Pi1.zzzz;\n\n    let ixy = perlinNoise3_permute4(perlinNoise3_permute4(ix) + iy);\n    let ixy0 = perlinNoise3_permute4(ixy + iz0);\n    let ixy1 = perlinNoise3_permute4(ixy + iz1);\n\n    var gx0: vec4f = ixy0 / 7.;\n    var gy0: vec4f = fract(floor(gx0) / 7.) - 0.5;\n    gx0 = fract(gx0);\n    var gz0: vec4f = vec4f(0.5) - abs(gx0) - abs(gy0);\n    var sz0: vec4f = step(gz0, vec4f(0.));\n    gx0 = gx0 + sz0 * (step(vec4f(0.), gx0) - 0.5);\n    gy0 = gy0 + sz0 * (step(vec4f(0.), gy0) - 0.5);\n\n    var gx1: vec4f = ixy1 / 7.;\n    var gy1: vec4f = fract(floor(gx1) / 7.) - 0.5;\n    gx1 = fract(gx1);\n    var gz1: vec4f = vec4f(0.5) - abs(gx1) - abs(gy1);\n    var sz1: vec4f = step(gz1, vec4f(0.));\n    gx1 = gx1 - sz1 * (step(vec4f(0.), gx1) - 0.5);\n    gy1 = gy1 - sz1 * (step(vec4f(0.), gy1) - 0.5);\n\n    var g000: vec3f = vec3f(gx0.x, gy0.x, gz0.x);\n    var g100: vec3f = vec3f(gx0.y, gy0.y, gz0.y);\n    var g010: vec3f = vec3f(gx0.z, gy0.z, gz0.z);\n    var g110: vec3f = vec3f(gx0.w, gy0.w, gz0.w);\n    var g001: vec3f = vec3f(gx1.x, gy1.x, gz1.x);\n    var g101: vec3f = vec3f(gx1.y, gy1.y, gz1.y);\n    var g011: vec3f = vec3f(gx1.z, gy1.z, gz1.z);\n    var g111: vec3f = vec3f(gx1.w, gy1.w, gz1.w);\n\n    let norm0 = taylorInvSqrt4(\n        vec4f(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 = g000 * norm0.x;\n    g010 = g010 * norm0.y;\n    g100 = g100 * norm0.z;\n    g110 = g110 * norm0.w;\n    let norm1 = taylorInvSqrt4(\n        vec4f(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 = g001 * norm1.x;\n    g011 = g011 * norm1.y;\n    g101 = g101 * norm1.z;\n    g111 = g111 * norm1.w;\n\n    let n000 = dot(g000, Pf0);\n    let n100 = dot(g100, vec3f(Pf1.x, Pf0.yz));\n    let n010 = dot(g010, vec3f(Pf0.x, Pf1.y, Pf0.z));\n    let n110 = dot(g110, vec3f(Pf1.xy, Pf0.z));\n    let n001 = dot(g001, vec3f(Pf0.xy, Pf1.z));\n    let n101 = dot(g101, vec3f(Pf1.x, Pf0.y, Pf1.z));\n    let n011 = dot(g011, vec3f(Pf0.x, Pf1.yz));\n    let n111 = dot(g111, Pf1);\n\n    var fade_xyz: vec3f = perlinNoise3_fade3(Pf0);\n    let temp = vec4f(f32(fade_xyz.z)); // simplify after chrome bug fix\n    let n_z = mix(vec4f(n000, n100, n010, n110), vec4f(n001, n101, n011, n111), temp);\n    let n_yz = mix(n_z.xy, n_z.zw, vec2f(f32(fade_xyz.y))); // simplify after chrome bug fix\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}"
        },
        {
          "name": "simplexNoise2D",
          "description": "simplex noise implementation for efficient 2D procedural generation.",
          "params": [
            {
              "name": "v",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value typically in range [-1, 1]."
          },
          "dependencies": [],
          "wgslCode": "fn snoise2D_permute3(x: vec3<f32>) -> vec3<f32> {\n    return ((x * 34.0 + 1.0) * x) % vec3<f32>(289.0);\n}\n\nfn snoise2D(v: vec2<f32>) -> f32 {\n    let C = vec4<f32>(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    var i = floor(v + dot(v, C.yy));\n    let x0 = v - i + dot(i, C.xx);\n    \n    var i1: vec2<f32>;\n    if (x0.x > x0.y) {\n        i1 = vec2<f32>(1.0, 0.0);\n    } else {\n        i1 = vec2<f32>(0.0, 1.0);\n    }\n    \n    var x12 = x0.xyxy + C.xxzz;\n    x12 = vec4<f32>(x12.xy - i1, x12.zw);\n    \n    i = i % vec2<f32>(289.0);\n    let p = snoise2D_permute3(snoise2D_permute3(i.y + vec3<f32>(0.0, i1.y, 1.0)) + i.x + vec3<f32>(0.0, i1.x, 1.0));\n    \n    var m = max(0.5 - vec3<f32>(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3<f32>(0.0));\n    m = m * m;\n    m = m * m;\n    \n    let x = 2.0 * fract(p * C.www) - 1.0;\n    let h = abs(x) - 0.5;\n    let ox = floor(x + 0.5);\n    let a0 = x - ox;\n    \n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n    \n    var g: vec3<f32>;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.y = a0.y * x12.x + h.y * x12.y;\n    g.z = a0.z * x12.z + h.z * x12.w;\n    \n    return 130.0 * dot(m, g);\n}"
        },
        {
          "name": "simplexNoise3D",
          "description": "simplex noise implementation for volumetric procedural generation.",
          "params": [
            {
              "name": "v",
              "type": "vec3<f32>",
              "description": "Input 3D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value typically in range [-1, 1]."
          },
          "dependencies": [],
          "wgslCode": "fn snoise3D_permute4(x: vec4<f32>) -> vec4<f32> {\n    return ((x * 34.0 + 1.0) * x) % vec4<f32>(289.0);\n}\n\nfn snoise3D_taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfn snoise3D(v: vec3<f32>) -> f32 {\n    let C = vec2<f32>(1.0 / 6.0, 1.0 / 3.0);\n    let D = vec4<f32>(0.0, 0.5, 1.0, 2.0);\n    \n    // First corner\n    var i = floor(v + dot(v, C.yyy));\n    let x0 = v - i + dot(i, C.xxx);\n    \n    // Other corners\n    let g = step(x0.yzx, x0.xyz);\n    let l = 1.0 - g;\n    let i1 = min(g.xyz, l.zxy);\n    let i2 = max(g.xyz, l.zxy);\n    \n    // x0 = x0 - 0. + 0.0 * C\n    let x1 = x0 - i1 + 1.0 * C.xxx;\n    let x2 = x0 - i2 + 2.0 * C.xxx;\n    let x3 = x0 - 1.0 + 3.0 * C.xxx;\n    \n    // Permutations\n    i = i % vec3<f32>(289.0);\n    let p = snoise3D_permute4(snoise3D_permute4(snoise3D_permute4(\n        i.z + vec4<f32>(0.0, i1.z, i2.z, 1.0)) +\n        i.y + vec4<f32>(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4<f32>(0.0, i1.x, i2.x, 1.0));\n    \n    // Gradients\n    // (N*N points uniformly over a square, mapped onto an octahedron.)\n    let n_ = 1.0 / 7.0; // N=7\n    let ns = n_ * D.wyz - D.xzx;\n    \n    let j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,N*N)\n    \n    let x_ = floor(j * ns.z);\n    let y_ = floor(j - 7.0 * x_); // mod(j,N)\n    \n    let x = x_ * ns.x + ns.yyyy;\n    let y = y_ * ns.x + ns.yyyy;\n    let h = 1.0 - abs(x) - abs(y);\n    \n    let b0 = vec4<f32>(x.xy, y.xy);\n    let b1 = vec4<f32>(x.zw, y.zw);\n    \n    let s0 = floor(b0) * 2.0 + 1.0;\n    let s1 = floor(b1) * 2.0 + 1.0;\n    let sh = -step(h, vec4<f32>(0.0));\n    \n    let a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    let a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    \n    var p0 = vec3<f32>(a0.xy, h.x);\n    var p1 = vec3<f32>(a0.zw, h.y);\n    var p2 = vec3<f32>(a1.xy, h.z);\n    var p3 = vec3<f32>(a1.zw, h.w);\n    \n    // Normalise gradients\n    let norm = snoise3D_taylorInvSqrt4(vec4<f32>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    \n    // Mix final noise value\n    var m = max(0.6 - vec4<f32>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), vec4<f32>(0.0));\n    m = m * m;\n    return 42.0 * dot(m * m, vec4<f32>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}"
        },
        {
          "name": "simplexNoise4D",
          "description": "simplex noise implementation for high-quality procedural generation.",
          "params": [
            {
              "name": "v",
              "type": "vec4<f32>",
              "description": "Input 4D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value typically in range [-1, 1]."
          },
          "dependencies": [
            "mod289",
            "taylorInvSqrt4"
          ],
          "wgslCode": "//! requires mod289 taylorInvSqrt4\nfn snoise_permute4(x: vec4<f32>) -> vec4<f32> {\n    return mod289(((x * 34.0) + 10.0) * x);\n}\n\nfn snoise_mod289f(x: f32) -> f32 {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfn snoise_permute(x: f32) -> f32 {\n    return snoise_mod289f(((x * 34.0) + 10.0) * x);\n}\n\nfn snoise_taylorInvSqrt(r: f32) -> f32 {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfn snoise_grad4(j: f32, ip: vec4<f32>) -> vec4<f32> {\n    let ones = vec4(1.0, 1.0, 1.0, -1.0);\n\n    var p: vec4<f32>;\n    var s: vec4<f32>;\n\n    p = vec4(floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0, p.w);\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = select(vec4(0.0), vec4(1.0), p < vec4(0.0));\n    p = vec4(p.xyz + (s.xyz * 2.0 - 1.0) * s.www, p.w);\n\n    return p;\n}\n\nfn snoise(v: vec4<f32>) -> f32 {\n    let C: vec4<f32> = vec4(\n        0.138196601125011, // (5 - sqrt(5))/20  G4\n        0.276393202250021, // 2 * G4\n        0.414589803375032, // 3 * G4\n        -0.447213595499958 // -1 + 4 * G4\n    );\n\n    // (sqrt(5) - 1)/4 = F4, used once below\n    let F4: f32 = 0.309016994374947451;\n\n    // First corner\n    var i: vec4<f32> = floor(v + dot(v, vec4(F4)));\n    var x0: vec4<f32> = v - i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    var i0: vec4<f32>;\n    var isX: vec3<f32> = step(x0.yzw, x0.xxx);\n    var isYZ: vec3<f32> = step(x0.zww, x0.yyz);\n\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    var minusX = 1.0 - isX;\n    i0.y = minusX.x;\n    i0.z = minusX.y;\n    i0.w = minusX.z;\n\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    var minusY = 1.0 - isYZ;\n    i0.z += minusY.x;\n    i0.w += minusY.y;\n    i0.z += isYZ.z;\n    i0.w += minusY.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    var i3: vec4<f32> = vec4<f32>(clamp(i0, vec4(0.0), vec4(1.0)));\n    var i2: vec4<f32> = clamp(i0 - vec4(1.0), vec4(0.0), vec4(1.0));\n    var i1: vec4<f32> = clamp(i0 - vec4(2.0), vec4(0.0), vec4(1.0));\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    var x1: vec4<f32> = x0 - i1 + C.xxxx;\n    var x2: vec4<f32> = x0 - i2 + C.yyyy;\n    var x3: vec4<f32> = x0 - i3 + C.zzzz;\n    var x4: vec4<f32> = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    var j0: f32 = snoise_permute(snoise_permute(snoise_permute(snoise_permute(i.w) + i.z) + i.y) + i.x);\n    var j1: vec4<f32> = snoise_permute4(snoise_permute4(snoise_permute4(snoise_permute4(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    var ip: vec4<f32> = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n\n    var p0: vec4<f32> = snoise_grad4(j0, ip);\n    var p1: vec4<f32> = snoise_grad4(j1.x, ip);\n    var p2: vec4<f32> = snoise_grad4(j1.y, ip);\n    var p3: vec4<f32> = snoise_grad4(j1.z, ip);\n    var p4: vec4<f32> = snoise_grad4(j1.w, ip);\n\n    // Normalise gradients\n    var norm: vec4<f32> = taylorInvSqrt4(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= snoise_taylorInvSqrt(dot(p4, p4));\n\n    // Mix contributions from the five corners\n    var m0: vec3<f32> = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), vec3(0.0));\n    var m1: vec2<f32> = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), vec2(0.0));\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n}"
        }
      ]
    },
    {
      "name": "SDF Primitives",
      "slug": "sdf-primitives",
      "description": "Basic SDF shapes and primitive geometry functions for ray marching.",
      "functions": [
        {
          "name": "sdfCircle",
          "description": "distance function for a circle.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Point to evaluate distance from."
            },
            {
              "name": "r",
              "type": "f32",
              "description": "Circle radius."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to circle surface (negative inside, positive outside)."
          },
          "dependencies": [],
          "wgslCode": "fn sdfCircle(p: vec2<f32>, r: f32) -> f32 {\n  return length(p) - r;\n}"
        },
        {
          "name": "sdfBox",
          "description": "distance function for a rectangular box.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Point to evaluate distance from."
            },
            {
              "name": "b",
              "type": "vec2<f32>",
              "description": "Box half-dimensions (width/2, height/2)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to box surface (negative inside, positive outside)."
          },
          "dependencies": [],
          "wgslCode": "fn sdfBox(p: vec2<f32>, b: vec2<f32>) -> f32 {\n  let d = abs(p) - b;\n  return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n}"
        },
        {
          "name": "sdfUnion",
          "description": "two SDFs using union operation (closest surface).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from first shape."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from second shape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing union of both shapes."
          },
          "dependencies": [],
          "wgslCode": "fn sdfUnion(d1: f32, d2: f32) -> f32 {\n  return min(d1, d2);\n}"
        },
        {
          "name": "sdfIntersection",
          "description": "two SDFs using intersection operation (overlapping area only).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from first shape."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from second shape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing intersection of both shapes."
          },
          "dependencies": [],
          "wgslCode": "fn sdfIntersection(d1: f32, d2: f32) -> f32 {\n  return max(d1, d2);\n}"
        },
        {
          "name": "sdfSubtraction",
          "description": "two SDFs using subtraction operation (first shape minus second).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from shape to subtract from."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from shape to subtract."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing first shape with second subtracted."
          },
          "dependencies": [],
          "wgslCode": "fn sdfSubtraction(d1: f32, d2: f32) -> f32 {\n  return max(-d1, d2);\n}"
        },
        {
          "name": "sdfBoxFrame",
          "description": "a signed distance field for a 3D box frame (hollow box).",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "vec3<f32>",
              "description": "Half-extents of the box."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Wall thickness of the frame."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the box frame surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfBoxFrame(position: vec3<f32>, size: vec3<f32>, thickness: f32) -> f32 {\n  let q = abs(position) - size;\n  let w = abs(q + thickness) - thickness;\n  return min(min(\n    length(max(vec3<f32>(q.x, w.y, w.z), vec3<f32>(0.0))) + min(max(q.x, max(w.y, w.z)), 0.0),\n    length(max(vec3<f32>(w.x, q.y, w.z), vec3<f32>(0.0))) + min(max(w.x, max(q.y, w.z)), 0.0)),\n    length(max(vec3<f32>(w.x, w.y, q.z), vec3<f32>(0.0))) + min(max(w.x, max(w.y, q.z)), 0.0));\n}"
        },
        {
          "name": "sdfCappedTorus",
          "description": "a signed distance field for a capped torus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "majorRadius",
              "type": "f32",
              "description": "Major radius of the torus."
            },
            {
              "name": "minorRadius",
              "type": "f32",
              "description": "Minor radius of the torus."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Cap angle in radians."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the capped torus surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfCappedTorus(position: vec3<f32>, majorRadius: f32, minorRadius: f32, angle: f32) -> f32 {\n  let sc = vec2<f32>(sin(angle), cos(angle));\n  let q = vec3<f32>(abs(position.x), position.y, position.z);\n  let k = select(\n    length(q.xy), \n    dot(q.xy, sc),\n    sc.y * q.x > sc.x * q.y\n  );\n  return sqrt(dot(q, q) + \n              majorRadius * majorRadius - \n              2.0 * majorRadius * k) - \n              minorRadius;\n}"
        },
        {
          "name": "sdfCapsule",
          "description": "a signed distance field for a capsule (cylinder with rounded caps).",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the capsule."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylindrical portion."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the capsule surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfCapsule(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let d = abs(length(position.xz)) - radius;\n  let p = vec2<f32>(d, abs(position.y) - height * 0.5);\n  return length(max(p, vec2<f32>(0.0))) + min(max(p.x, p.y), 0.0) - radius;\n}"
        },
        {
          "name": "sdfCone",
          "description": "a signed distance field for a cone.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Base radius of the cone."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cone."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the cone surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfCone(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let q = vec2<f32>(length(position.xz), position.y);\n  let h = height;\n  let r = radius;\n  \n  // Calculate distance\n  let d1 = -q.y - h;\n  let d2 = max(q.x * h - q.y * r, q.y * h + q.x * r);\n  \n  return length(max(vec2<f32>(d1, d2), vec2<f32>(0.0))) + min(max(d1, d2), 0.0);\n}"
        },
        {
          "name": "sdfCylinder",
          "description": "a signed distance field for a cylinder.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the cylinder."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylinder."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the cylinder surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfCylinder(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let d = vec2<f32>(length(position.xz), abs(position.y)) - vec2<f32>(radius, height * 0.5);\n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0)));\n}"
        },
        {
          "name": "sdfEllipsoid",
          "description": "a signed distance field for an ellipsoid.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "vec3<f32>",
              "description": "Radii along each axis."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the ellipsoid surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfEllipsoid(position: vec3<f32>, radius: vec3<f32>) -> f32 {\n  let k0 = length(position / radius);\n  let k1 = length(position / (radius * radius));\n  return k0 * (k0 - 1.0) / k1;\n}"
        },
        {
          "name": "sdfGyroid",
          "description": "a signed distance field for a gyroid surface.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "scale",
              "type": "f32",
              "description": "Scale factor for the gyroid pattern."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Thickness of the gyroid surface."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the gyroid surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfGyroid(position: vec3<f32>, scale: f32, thickness: f32) -> f32 {\n  let p = position * scale;\n  return (abs(dot(sin(p), cos(p.zxy))) - thickness) / scale;\n}"
        },
        {
          "name": "sdfHexagonalPrism",
          "description": "a signed distance field for a hexagonal prism.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the hexagon."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the prism."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the hexagonal prism surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfHexagonalPrism(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  // Project into 2D\n  var p = abs(position);\n  let k = vec3<f32>(-0.866025404, 0.5, 0.577350269);\n  \n  // Hexagon in xy-plane\n  p = vec3<f32>(p.x + p.y * k.x, p.y * k.y, p.z);\n  p = vec3<f32>(p.x - min(p.x, p.y), p.y, p.z);\n  let d = vec2<f32>(length(vec2<f32>(p.x, p.y - radius * k.z)) - radius, abs(p.z) - height * 0.5);\n  \n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0)));\n}"
        },
        {
          "name": "sdfIcosahedron",
          "description": "a signed distance field for an icosahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the icosahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the icosahedron surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfIcosahedron(position: vec3<f32>, size: f32) -> f32 {\n  var p = position;\n  let s = size;\n  \n  // Constants for icosahedron\n  let phi = 1.618033988749895;\n  let a = s;\n  let b = s * phi;\n  \n  // Compute distance to icosahedron\n  p = abs(p / s);\n  let d = p.x * p.y * p.z;\n  let m = max(max(p.x, p.y), p.z);\n  let n = min(min(p.x, p.y), p.z);\n  let mid = p.x + p.y + p.z - m - n;\n  \n  // Calculate the signed distance\n  let q = select(mid, d, m < phi * n);\n  return (length(p) - phi) * s;\n}"
        },
        {
          "name": "sdfJulia",
          "description": "a signed distance field for a 4D Julia set fractal.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "c",
              "type": "vec4<f32>",
              "description": "Julia set parameter (quaternion)."
            },
            {
              "name": "iterations",
              "type": "f32",
              "description": "Maximum number of iterations."
            },
            {
              "name": "bailout",
              "type": "f32",
              "description": "Bailout radius for iteration escape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the Julia set surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfJulia(position: vec3<f32>, c: vec4<f32>, iterations: f32, bailout: f32) -> f32 {\n  var z = vec4<f32>(position, 0.0);\n  var dz = vec4<f32>(1.0, 0.0, 0.0, 0.0);\n  var m = dot(z, z);\n  var i = 0;\n  \n  // Julia set iteration\n  for (i = 0; i < i32(iterations) && m < bailout * bailout; i += 1) {\n    // Quaternion multiplication for dz = 2.0 * z * dz\n    dz = 2.0 * vec4<f32>(\n      z.x * dz.x - z.y * dz.y - z.z * dz.z - z.w * dz.w,\n      z.x * dz.y + z.y * dz.x + z.z * dz.w - z.w * dz.z,\n      z.x * dz.z - z.y * dz.w + z.z * dz.x + z.w * dz.y,\n      z.x * dz.w + z.y * dz.z - z.z * dz.y + z.w * dz.x\n    );\n    \n    // Quaternion multiplication for z = z * z + c\n    z = vec4<f32>(\n      z.x * z.x - z.y * z.y - z.z * z.z - z.w * z.w,\n      z.x * z.y + z.y * z.x + z.z * z.w - z.w * z.z,\n      z.x * z.z - z.y * z.w + z.z * z.x + z.w * z.y,\n      z.x * z.w + z.y * z.z - z.z * z.y + z.w * z.x\n    ) + c;\n    \n    m = dot(z, z);\n  }\n  \n  // Compute the distance\n  let dist = 0.5 * log(m) * sqrt(m) / length(dz);\n  return dist;\n}"
        },
        {
          "name": "sdfOctahedron",
          "description": "a signed distance field for an octahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the octahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the octahedron surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfOctahedron(position: vec3<f32>, size: f32) -> f32 {\n  let p = abs(position);\n  let m = p.x + p.y + p.z - size;\n  \n  // Calculate the distance\n  var q: vec3<f32>;\n  if (3.0 * p.x < m) {\n    q = p;\n  } else if (3.0 * p.y < m) {\n    q = vec3<f32>(p.x, p.z, p.y);\n  } else if (3.0 * p.z < m) {\n    q = vec3<f32>(p.x, p.y, p.z);\n  } else {\n    q = p;\n  }\n  \n  let k = clamp(0.5 * (q.z - q.y + size), 0.0, size);\n  return length(vec3<f32>(q.x, q.y - size + k, q.z - k));\n}"
        },
        {
          "name": "sdfPlane",
          "description": "a signed distance field for an infinite plane.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "normal",
              "type": "vec3<f32>",
              "description": "Normal vector of the plane (should be normalized)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the plane surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfPlane(position: vec3<f32>, normal: vec3<f32>) -> f32 {\n  let n = normalize(normal);\n  return dot(position, n);\n}"
        },
        {
          "name": "sdfPyramid",
          "description": "a signed distance field for a pyramid.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Base size of the pyramid."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the pyramid."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the pyramid surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfPyramid(position: vec3<f32>, size: f32, height: f32) -> f32 {\n  // Normalize position\n  var p = position;\n  let h = height;\n  let m2 = h * h + size * size;\n  \n  // Project into 2D\n  let q = abs(p);\n  p.y -= h;\n  p.y = max(p.y, 0.0);\n  \n  // Distance calculation\n  var d: f32;\n  if (max(q.x, q.z) < size) {\n    d = length(vec2<f32>(length(p.xz), p.y)) - sqrt(m2);\n  } else {\n    d = length(vec2<f32>(length(max(abs(p.xz) - vec2<f32>(size), vec2<f32>(0.0))), p.y));\n  }\n  \n  // Account for position below base\n  d = select(d, length(p) - sqrt(m2), p.y < 0.0);\n  \n  return d;\n}"
        },
        {
          "name": "sdfRhombus",
          "description": "a signed distance field for a rhombus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "dimensions",
              "type": "vec3<f32>",
              "description": "Dimensions of the rhombus."
            },
            {
              "name": "sharpness",
              "type": "f32",
              "description": "Sharpness factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rhombus surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfRhombus(position: vec3<f32>, dimensions: vec3<f32>, sharpness: f32) -> f32 {\n  var p = abs(position);\n  let b = dimensions;\n  let e = sharpness;\n  \n  // Calculate distance to rhombus\n  p = p - b;\n  let q = abs(p.x + p.y + p.z) + e;\n  let h = max(vec3<f32>(q) - vec3<f32>(e), vec3<f32>(0.0));\n  \n  return min(max(p.x, max(p.y, p.z)), 0.0) + length(h);\n}"
        },
        {
          "name": "sdfRoundBox",
          "description": "a signed distance field for a rounded box.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "vec3<f32>",
              "description": "Half-extents of the box."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Rounding radius for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded box surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfRoundBox(position: vec3<f32>, size: vec3<f32>, radius: f32) -> f32 {\n  let q = abs(position) - size;\n  return length(max(q, vec3<f32>(0.0))) + \n         min(max(q.x, max(q.y, q.z)), 0.0) - \n         radius;\n}"
        },
        {
          "name": "sdfRoundedCone",
          "description": "a signed distance field for a rounded cone.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius1",
              "type": "f32",
              "description": "Bottom radius of the cone."
            },
            {
              "name": "radius2",
              "type": "f32",
              "description": "Top radius of the cone."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cone."
            },
            {
              "name": "roundness",
              "type": "f32",
              "description": "Rounding factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded cone surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfRoundedCone(position: vec3<f32>, radius1: f32, radius2: f32, height: f32, roundness: f32) -> f32 {\n  // Calculate distances\n  let p = position;\n  let r1 = radius1 - roundness;\n  let r2 = radius2 - roundness;\n  let h = height;\n  \n  // Squared distance from axis\n  let q = length(p.xz);\n  \n  // Project into 2D space\n  let k1 = (r2 - r1) / h;\n  let k2 = h / (r1 - r2);\n  let projected = vec2<f32>(q - r1 + r1 * (p.y / h) * (r1 - r2) / r1, p.y - h);\n  let ca = p.y * k1 - q;\n  let cb = p.y - r1 * k2 + q * k2;\n  \n  var s: f32;\n  if (ca < 0.0 && projected.y < 0.0) {\n    s = length(projected) - roundness;\n  } else if (ca > 0.0 && cb < 0.0) {\n    s = -ca - roundness;\n  } else {\n    s = length(vec2<f32>(max(ca, 0.0), max(projected.y, 0.0))) - roundness;\n  }\n  \n  return s;\n}"
        },
        {
          "name": "sdfRoundedCylinder",
          "description": "a signed distance field for a rounded cylinder.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the cylinder."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylinder."
            },
            {
              "name": "roundness",
              "type": "f32",
              "description": "Rounding factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded cylinder surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfRoundedCylinder(position: vec3<f32>, radius: f32, height: f32, roundness: f32) -> f32 {\n  // Calculate distances\n  let radiusOffset = radius - roundness;\n  let heightOffset = height * 0.5 - roundness;\n  \n  // Generate rounded cylinder\n  let d = vec2<f32>(length(position.xz) - radiusOffset, abs(position.y) - heightOffset);\n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0))) - roundness;\n}"
        },
        {
          "name": "sdfSphere",
          "description": "a signed distance field for a sphere.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the sphere."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the sphere surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfSphere(position: vec3<f32>, radius: f32) -> f32 {\n  return length(position) - radius;\n}"
        },
        {
          "name": "sdfTetrahedron",
          "description": "a signed distance field for a tetrahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the tetrahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the tetrahedron surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfTetrahedron(position: vec3<f32>, size: f32) -> f32 {\n  var p = position;\n  let s = size;\n  \n  // Set initial values\n  let signVal = sign(p.x + p.y + p.z);\n  p.x = abs(p.x);\n  p.y = abs(p.y);\n  p.z = abs(p.z);\n  \n  // Calculate the distance\n  if (p.x < p.y) {\n    let t = p.x;\n    p.x = p.y;\n    p.y = t;\n  }\n  if (p.x < p.z) {\n    let t = p.x;\n    p.x = p.z;\n    p.z = t;\n  }\n  if (p.y < p.z) {\n    let t = p.y;\n    p.y = p.z;\n    p.z = t;\n  }\n  \n  let k = clamp((p.x + p.z - p.y) * 0.5, 0.0, p.z);\n  return signVal * (length(vec3<f32>(p.x, p.y - s, p.z - k)) - s);\n}"
        },
        {
          "name": "sdfTorus",
          "description": "a signed distance field for a torus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "majorRadius",
              "type": "f32",
              "description": "Major radius of the torus."
            },
            {
              "name": "minorRadius",
              "type": "f32",
              "description": "Minor radius of the torus."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the torus surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfTorus(position: vec3<f32>, majorRadius: f32, minorRadius: f32) -> f32 {\n  let q = vec2<f32>(length(position.xz) - majorRadius, position.y);\n  return length(q) - minorRadius;\n}"
        },
        {
          "name": "sdfTriangularPrism",
          "description": "a signed distance field for a triangular prism.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the triangular base."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the prism."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the triangular prism surface."
          },
          "dependencies": [],
          "wgslCode": "fn sdfTriangularPrism(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  var q = abs(position);\n  \n  // Triangle distance in xy-plane\n  let k = sqrt(3.0);\n  q.x = abs(q.x - q.y * k * 0.5);\n  q.y = q.y * 0.866025404 + q.x * 0.5;\n  \n  // Combine with z distance\n  let d1 = vec2<f32>(q.x - radius, q.y);\n  let d2 = vec2<f32>(q.y - radius, q.x);\n  let d = min(d1, d2);\n  \n  // Account for height\n  let h = height * 0.5;\n  let dz = q.z - h;\n  let dz2 = max(dz, 0.0);\n  \n  return length(max(vec2<f32>(max(d.x, 0.0), dz2), vec2<f32>(0.0))) + min(max(d.x, dz), 0.0);\n}"
        }
      ]
    },
    {
      "name": "Color & Graphics",
      "slug": "color---graphics",
      "description": "Color space conversion and palette generation functions.",
      "functions": [
        {
          "name": "palette",
          "description": "colors using cosine-based palette function for smooth color gradients.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (typically 0-1) for palette lookup."
            },
            {
              "name": "a",
              "type": "vec3<f32>",
              "description": "Offset values for RGB channels."
            },
            {
              "name": "b",
              "type": "vec3<f32>",
              "description": "Amplitude values for RGB channels."
            },
            {
              "name": "c",
              "type": "vec3<f32>",
              "description": "Frequency values for RGB channels."
            },
            {
              "name": "d",
              "type": "vec3<f32>",
              "description": "Phase values for RGB channels."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "RGB color."
          },
          "dependencies": [],
          "wgslCode": "fn palette(t: f32, a: vec3<f32>, b: vec3<f32>, c: vec3<f32>, d: vec3<f32>) -> vec3<f32> {\n  return a + b * cos(6.28318 * (c * t + d));\n}"
        },
        {
          "name": "linearToSrgb",
          "description": "linear RGB color values to sRGB color space.",
          "params": [
            {
              "name": "color",
              "type": "vec3<f32>",
              "description": "Linear RGB color values."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "color values."
          },
          "dependencies": [],
          "wgslCode": "fn linearToSrgb(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3(1.0 / 2.2));\n}"
        },
        {
          "name": "srgbToLinear",
          "description": "sRGB color values to linear RGB color space.",
          "params": [
            {
              "name": "color",
              "type": "vec3<f32>",
              "description": "sRGB color values."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "RGB color values."
          },
          "dependencies": [],
          "wgslCode": "fn srgbToLinear(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3(2.2));\n}"
        },
        {
          "name": "hueToRgb",
          "description": "function for HSL to RGB conversion - converts hue component to RGB.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "First HSL conversion parameter."
            },
            {
              "name": "q",
              "type": "f32",
              "description": "Second HSL conversion parameter."
            },
            {
              "name": "t",
              "type": "f32",
              "description": "Hue value (adjusted)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "component value."
          },
          "dependencies": [],
          "wgslCode": "fn hueToRgb(p: f32, q: f32, t: f32) -> f32 {\n  var t_adj = t;\n  if (t_adj < 0.0) { t_adj += 1.0; }\n  if (t_adj > 1.0) { t_adj -= 1.0; }\n  if (t_adj < 1.0 / 6.0) { return p + (q - p) * 6.0 * t_adj; }\n  if (t_adj < 1.0 / 2.0) { return q; }\n  if (t_adj < 2.0 / 3.0) { return p + (q - p) * (2.0 / 3.0 - t_adj) * 6.0; }\n  return p;\n}"
        },
        {
          "name": "hslToRgb",
          "description": "HSL (Hue, Saturation, Lightness) color to RGB.",
          "params": [
            {
              "name": "hsl",
              "type": "vec3<f32>",
              "description": "HSL color values (hue: 0-1, saturation: 0-1, lightness: 0-1)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "color values."
          },
          "dependencies": [
            "hueToRgb"
          ],
          "wgslCode": "//! requires hueToRgb\nfn hslToRgb(hsl: vec3<f32>) -> vec3<f32> {\n  let h = hsl.x;\n  let s = hsl.y;\n  let l = hsl.z;\n  \n  if (s == 0.0) {\n    return vec3(l); // achromatic\n  }\n  \n  let q = select(l * (1.0 + s), l + s - l * s, l < 0.5);\n  let p = 2.0 * l - q;\n  \n  return vec3(\n    hueToRgb(p, q, h + 1.0 / 3.0),\n    hueToRgb(p, q, h),\n    hueToRgb(p, q, h - 1.0 / 3.0)\n  );\n}"
        }
      ]
    },
    {
      "name": "Animation & Easing",
      "slug": "animation---easing",
      "description": "Easing functions and animation curves for smooth transitions.",
      "functions": [
        {
          "name": "bezierCubic",
          "description": "a cubic Bezier curve and returns both value and derivative.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Parameter along the curve (0-1)."
            },
            {
              "name": "p0",
              "type": "f32",
              "description": "First control point."
            },
            {
              "name": "p1",
              "type": "f32",
              "description": "Second control point."
            },
            {
              "name": "p2",
              "type": "f32",
              "description": "Third control point."
            },
            {
              "name": "p3",
              "type": "f32",
              "description": "Fourth control point."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative (tangent)."
          },
          "dependencies": [],
          "wgslCode": "fn bezierCubic(t: f32, p0: f32, p1: f32, p2: f32, p3: f32) -> vec2<f32> {\n  // Clamp t to [0,1]\n  let tt = clamp(t, 0.0, 1.0);\n  \n  // Calculate curve value using cubic Bezier formula\n  // P(t) = (1-t)³P₀ + 3(1-t)²tP₁ + 3(1-t)t²P₂ + t³P₃\n  let t1 = 1.0 - tt;\n  let t1Squared = t1 * t1;\n  let t1Cubed = t1Squared * t1;\n  let tSquared = tt * tt;\n  let tCubed = tSquared * tt;\n  \n  let value = t1Cubed * p0 + \n             3.0 * t1Squared * tt * p1 + \n             3.0 * t1 * tSquared * p2 + \n             tCubed * p3;\n  \n  // Calculate derivative for tangent information\n  // P'(t) = 3(1-t)²(P₁-P₀) + 6(1-t)t(P₂-P₁) + 3t²(P₃-P₂)\n  let derivative = 3.0 * t1Squared * (p1 - p0) +\n                  6.0 * t1 * tt * (p2 - p1) +\n                  3.0 * tSquared * (p3 - p2);\n  \n  return vec2<f32>(value, derivative);\n}"
        },
        {
          "name": "easeIn",
          "description": "ease-in function for smooth acceleration.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            },
            {
              "name": "power",
              "type": "f32",
              "description": "Easing power (higher = more pronounced curve)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value."
          },
          "dependencies": [],
          "wgslCode": "fn easeIn(t: f32, power: f32) -> f32 {\n  return pow(clamp(t, 0.0, 1.0), power);\n}"
        },
        {
          "name": "easeOut",
          "description": "ease-out function for smooth deceleration.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            },
            {
              "name": "power",
              "type": "f32",
              "description": "Easing power (higher = more pronounced curve)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value."
          },
          "dependencies": [],
          "wgslCode": "fn easeOut(t: f32, power: f32) -> f32 {\n  return 1.0 - pow(1.0 - clamp(t, 0.0, 1.0), power);\n}"
        },
        {
          "name": "easeInOut",
          "description": "ease-in-out function for smooth acceleration and deceleration.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            },
            {
              "name": "power",
              "type": "f32",
              "description": "Easing power (higher = more pronounced curve)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value."
          },
          "dependencies": [],
          "wgslCode": "fn easeInOut(t: f32, power: f32) -> f32 {\n  let tt = clamp(t, 0.0, 1.0);\n  if (tt < 0.5) {\n    return 0.5 * pow(2.0 * tt, power);\n  } else {\n    return 0.5 + 0.5 * (1.0 - pow(2.0 * (1.0 - tt), power));\n  }\n}"
        },
        {
          "name": "elasticIn",
          "description": "ease-in function with oscillating motion.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value with elastic effect."
          },
          "dependencies": [],
          "wgslCode": "fn elasticIn(t: f32) -> f32 {\n  let tt = clamp(t, 0.0, 1.0);\n  return sin(13.0 * 3.14159 * tt) * pow(2.0, 10.0 * (tt - 1.0));\n}"
        },
        {
          "name": "elasticOut",
          "description": "ease-out function with oscillating motion.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value with elastic effect."
          },
          "dependencies": [],
          "wgslCode": "fn elasticOut(t: f32) -> f32 {\n  let tt = clamp(t, 0.0, 1.0);\n  return sin(-13.0 * 3.14159 * (tt + 1.0)) * pow(2.0, -10.0 * tt) + 1.0;\n}"
        },
        {
          "name": "backIn",
          "description": "ease-in function that overshoots before settling.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value with back effect."
          },
          "dependencies": [],
          "wgslCode": "fn backIn(t: f32) -> f32 {\n  let s = 1.70158;\n  let tt = clamp(t, 0.0, 1.0);\n  return tt * tt * ((s + 1.0) * tt - s);\n}"
        },
        {
          "name": "backOut",
          "description": "ease-out function that overshoots before settling.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value with back effect."
          },
          "dependencies": [],
          "wgslCode": "fn backOut(t: f32) -> f32 {\n  let s = 1.70158;\n  let tt = clamp(t, 0.0, 1.0);\n  let tMinus = tt - 1.0;\n  return tMinus * tMinus * ((s + 1.0) * tMinus + s) + 1.0;\n}"
        },
        {
          "name": "springPhysics",
          "description": "spring animation with configurable parameters.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Time parameter."
            },
            {
              "name": "targetPosition",
              "type": "f32",
              "description": "Target position for the spring."
            },
            {
              "name": "initialPos",
              "type": "f32",
              "description": "Initial position."
            },
            {
              "name": "initialVel",
              "type": "f32",
              "description": "Initial velocity."
            },
            {
              "name": "stiffness",
              "type": "f32",
              "description": "Spring stiffness coefficient."
            },
            {
              "name": "damping",
              "type": "f32",
              "description": "Damping coefficient."
            },
            {
              "name": "mass",
              "type": "f32",
              "description": "Mass of the spring system."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "and velocity at time t."
          },
          "dependencies": [],
          "wgslCode": "fn springPhysics(t: f32, targetPosition: f32, initialPos: f32, initialVel: f32, stiffness: f32, damping: f32, mass: f32) -> vec2<f32> {\n  // Ensure positive values for stiffness, damping, and mass\n  let k = max(0.0001, stiffness);\n  let d = max(0.0, damping);\n  let m = max(0.0001, mass);\n  \n  // Calculate the angular frequency and damping ratio\n  let omega = sqrt(k / m);\n  let zeta = d / (2.0 * sqrt(k * m));\n  \n  // Initial displacement from targetPosition position\n  let x0 = initialPos - targetPosition;\n  let v0 = initialVel;\n  \n  var position: f32 = 0.0;\n  var velocity: f32 = 0.0;\n  \n  if (zeta < 1.0) {\n    // Underdamped case\n    let omega_d = omega * sqrt(1.0 - zeta * zeta);\n    let A = x0;\n    let B = (v0 + zeta * omega * x0) / omega_d;\n    \n    // Calculate exponential decay term\n    let expTerm = exp(-zeta * omega * t);\n    \n    // Calculate position and velocity\n    position = targetPosition + expTerm * (A * cos(omega_d * t) + B * sin(omega_d * t));\n    velocity = expTerm * (\n                -zeta * omega * A * cos(omega_d * t) - omega_d * A * sin(omega_d * t) +\n                -zeta * omega * B * sin(omega_d * t) + omega_d * B * cos(omega_d * t)\n               );\n  } else if (zeta == 1.0) {\n    // Critically damped case\n    let A = x0;\n    let B = v0 + omega * x0;\n    \n    // Calculate exponential decay term\n    let expTerm = exp(-omega * t);\n    \n    // Calculate position and velocity\n    position = targetPosition + expTerm * (A + B * t);\n    velocity = expTerm * (B - omega * (A + B * t));\n  } else {\n    // Overdamped case\n    let omega1 = -omega * (zeta + sqrt(zeta * zeta - 1.0));\n    let omega2 = -omega * (zeta - sqrt(zeta * zeta - 1.0));\n    \n    let A = (v0 - omega2 * x0) / (omega1 - omega2);\n    let B = x0 - A;\n    \n    // Calculate position and velocity\n    position = targetPosition + A * exp(omega1 * t) + B * exp(omega2 * t);\n    velocity = A * omega1 * exp(omega1 * t) + B * omega2 * exp(omega2 * t);\n  }\n  \n  return vec2<f32>(position, velocity);\n}"
        }
      ]
    },
    {
      "name": "Wave Functions",
      "slug": "wave-functions",
      "description": "Wave generation functions for oscillations and periodic patterns.",
      "functions": [
        {
          "name": "triangleWave",
          "description": "a triangle wave with configurable frequency and amplitude.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "dependencies": [],
          "wgslCode": "fn triangleWave(x: f32, frequency: f32, amplitude: f32, phase: f32) -> f32 {\n  let t = x * frequency + phase;\n  let tt = fract(t);\n  let result = abs(2.0 * tt - 1.0);\n  return (1.0 - result) * amplitude;\n}"
        },
        {
          "name": "sawtoothWave",
          "description": "a sawtooth wave with linear ramp.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "dependencies": [],
          "wgslCode": "fn sawtoothWave(x: f32, frequency: f32, amplitude: f32, phase: f32) -> f32 {\n  let t = x * frequency + phase;\n  let tt = fract(t);\n  return tt * amplitude;\n}"
        },
        {
          "name": "squareWave",
          "description": "a square wave with configurable duty cycle.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset."
            },
            {
              "name": "dutyCycle",
              "type": "f32",
              "description": "Duty cycle (0-1) for wave on/off ratio."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "dependencies": [],
          "wgslCode": "fn squareWave(x: f32, frequency: f32, amplitude: f32, phase: f32, dutyCycle: f32) -> f32 {\n  let t = x * frequency + phase;\n  let tt = fract(t);\n  return select(0.0, amplitude, tt < dutyCycle);\n}"
        },
        {
          "name": "pulseWave",
          "description": "a pulse wave with smooth falloff edges.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset."
            },
            {
              "name": "width",
              "type": "f32",
              "description": "Pulse width (0-1)."
            },
            {
              "name": "falloff",
              "type": "f32",
              "description": "Smooth falloff duration."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "dependencies": [],
          "wgslCode": "fn pulseWave(x: f32, frequency: f32, amplitude: f32, phase: f32, width: f32, falloff: f32) -> f32 {\n  let t = x * frequency + phase;\n  let tt = fract(t);\n  \n  // Create a pulse with smooth edges\n  var pulse = 0.0;\n  \n  // If tt is within the width, pulse is 1.0\n  if (tt < width) {\n    pulse = 1.0;\n  } else if (tt < width + falloff) {\n    // Smooth falloff\n    pulse = 1.0 - (tt - width) / falloff;\n  }\n  \n  return pulse * amplitude;\n}"
        },
        {
          "name": "chirpWave",
          "description": "a chirp wave with linearly changing frequency.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "startFrequency",
              "type": "f32",
              "description": "Starting frequency."
            },
            {
              "name": "endFrequency",
              "type": "f32",
              "description": "Ending frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "period",
              "type": "f32",
              "description": "Period over which frequency changes."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "dependencies": [],
          "wgslCode": "fn chirpWave(x: f32, startFrequency: f32, endFrequency: f32, amplitude: f32, period: f32) -> f32 {\n  // Calculate the time within the current period\n  let t = fract(x / period);\n  \n  // Calculate the frequency at the current time (linear interpolation)\n  let freq = mix(startFrequency, endFrequency, t);\n  \n  // Calculate the phase which increases with changing frequency\n  let k = (endFrequency - startFrequency) / period;\n  let phase = 2.0 * 3.14159 * (startFrequency * t + 0.5 * k * t * t);\n  \n  // Return the sine wave with the calculated phase\n  return sin(phase) * amplitude;\n}"
        },
        {
          "name": "noiseWave",
          "description": "a wave using interpolated noise for organic variation.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "seed",
              "type": "f32",
              "description": "Random seed for noise generation."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "dependencies": [
            "hash1D"
          ],
          "wgslCode": "//! requires hash1D\nfn noiseWave(x: f32, frequency: f32, amplitude: f32, seed: f32) -> f32 {\n  // Create interpolated noise\n  let t = x * frequency;\n  let floorT = floor(t);\n  let fractT = fract(t);\n  \n  // Get four noise values and interpolate between them\n  let n0 = hash1D(floorT + seed);\n  let n1 = hash1D(floorT + 1.0 + seed);\n  \n  // Smooth interpolation\n  let u = fractT * fractT * (3.0 - 2.0 * fractT); // Smoothstep\n  \n  return mix(n0, n1, u) * amplitude;\n}"
        }
      ]
    },
    {
      "name": "SDF Operations",
      "slug": "sdf-operations",
      "description": "Boolean operations for combining and modifying signed distance fields.",
      "functions": [
        {
          "name": "sdfOpUnion",
          "description": "two SDFs using union operation (logical OR).",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfOpUnion(distanceA: f32, distanceB: f32) -> f32 {\n  return min(distanceA, distanceB);\n}"
        },
        {
          "name": "sdfOpSubtract",
          "description": "one SDF from another (A - B).",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field to subtract."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfOpSubtract(distanceA: f32, distanceB: f32) -> f32 {\n  return max(distanceA, -distanceB);\n}"
        },
        {
          "name": "sdfOpIntersect",
          "description": "two SDFs (logical AND).",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfOpIntersect(distanceA: f32, distanceB: f32) -> f32 {\n  return max(distanceA, distanceB);\n}"
        },
        {
          "name": "sdfSmoothUnion",
          "description": "two SDFs using smooth union operation with configurable smoothing.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for the blend."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "combined signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfSmoothUnion(distanceA: f32, distanceB: f32, smoothing: f32) -> f32 {\n  let h = clamp(0.5 + 0.5 * (distanceB - distanceA) / smoothing, 0.0, 1.0);\n  return mix(distanceB, distanceA, h) - smoothing * h * (1.0 - h);\n}"
        },
        {
          "name": "sdfSmoothSubtract",
          "description": "one SDF from another with smooth blending.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field to subtract."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for the blend."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "subtracted signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfSmoothSubtract(distanceA: f32, distanceB: f32, smoothing: f32) -> f32 {\n  let h = clamp(0.5 - 0.5 * (distanceB + distanceA) / smoothing, 0.0, 1.0);\n  return mix(distanceA, -distanceB, h) + smoothing * h * (1.0 - h);\n}"
        },
        {
          "name": "sdfSmoothIntersect",
          "description": "two SDFs with smooth blending.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for the blend."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "intersected signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfSmoothIntersect(distanceA: f32, distanceB: f32, smoothing: f32) -> f32 {\n  let h = clamp(0.5 - 0.5 * (distanceB - distanceA) / smoothing, 0.0, 1.0);\n  return mix(distanceB, distanceA, h) + smoothing * h * (1.0 - h);\n}"
        },
        {
          "name": "sdfChamferUnion",
          "description": "two SDFs using chamfer union operation with hard edges.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Chamfer radius for the edge."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "union signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfChamferUnion(distanceA: f32, distanceB: f32, radius: f32) -> f32 {\n  return min(min(distanceA, distanceB), (distanceA - radius + distanceB) * 0.5);\n}"
        },
        {
          "name": "sdfChamferSubtract",
          "description": "one SDF from another using chamfer operation.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field to subtract."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Chamfer radius for the edge."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "subtraction signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfChamferSubtract(distanceA: f32, distanceB: f32, radius: f32) -> f32 {\n  return max(max(distanceA, -distanceB), (distanceA + radius - distanceB) * 0.5);\n}"
        },
        {
          "name": "sdfChamferIntersect",
          "description": "two SDFs using chamfer operation.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Chamfer radius for the edge."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "intersection signed distance field."
          },
          "dependencies": [],
          "wgslCode": "fn sdfChamferIntersect(distanceA: f32, distanceB: f32, radius: f32) -> f32 {\n  return max(max(distanceA, distanceB), (distanceA + radius + distanceB) * 0.5);\n}"
        }
      ]
    },
    {
      "name": "SDF Transforms",
      "slug": "sdf-transforms",
      "description": "Spatial transformation functions for positioning and orienting SDFs.",
      "functions": [
        {
          "name": "sdfTranslate",
          "description": "an SDF by moving its position.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "offset",
              "type": "vec3<f32>",
              "description": "Translation offset."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfTranslate(position: vec3<f32>, offset: vec3<f32>) -> vec3<f32> {\n  return position - offset;\n}"
        },
        {
          "name": "sdfScale",
          "description": "an SDF uniformly or non-uniformly.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "scale",
              "type": "vec3<f32>",
              "description": "Scale factors for each axis."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfScale(position: vec3<f32>, scale: vec3<f32>) -> vec3<f32> {\n  return position / scale;\n}"
        },
        {
          "name": "sdfRotate",
          "description": "an SDF around a pivot point with Euler angles.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "angles",
              "type": "vec3<f32>",
              "description": "Rotation angles in radians (x, y, z)."
            },
            {
              "name": "pivot",
              "type": "vec3<f32>",
              "description": "Point to rotate around."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfRotate(position: vec3<f32>, angles: vec3<f32>, pivot: vec3<f32>) -> vec3<f32> {\n  // First translate to origin relative to pivot point\n  let centered = position - pivot;\n  \n  // Create rotation matrices (inverse rotation = negative angles)\n  let cx = cos(-angles.x);\n  let sx = sin(-angles.x);\n  let cy = cos(-angles.y);\n  let sy = sin(-angles.y);\n  let cz = cos(-angles.z);\n  let sz = sin(-angles.z);\n  \n  // Rotate around X axis\n  let rx = vec3<f32>(\n    centered.x,\n    centered.y * cx - centered.z * sx,\n    centered.y * sx + centered.z * cx\n  );\n  \n  // Rotate around Y axis\n  let ry = vec3<f32>(\n    rx.x * cy + rx.z * sy,\n    rx.y,\n    -rx.x * sy + rx.z * cy\n  );\n  \n  // Rotate around Z axis\n  let rz = vec3<f32>(\n    ry.x * cz - ry.y * sz,\n    ry.x * sz + ry.y * cz,\n    ry.z\n  );\n  \n  // Translate back from pivot point\n  return rz + pivot;\n}"
        },
        {
          "name": "sdfMirror",
          "description": "an SDF across a plane defined by a normal vector.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "normal",
              "type": "vec3<f32>",
              "description": "Normal vector of the mirror plane."
            },
            {
              "name": "offset",
              "type": "f32",
              "description": "Distance offset of the mirror plane."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfMirror(position: vec3<f32>, normal: vec3<f32>, offset: f32) -> vec3<f32> {\n  let n = normalize(normal);\n  let d = dot(position, n) - offset;\n  return position - 2.0 * max(0.0, d) * n;\n}"
        },
        {
          "name": "sdfPolarRepeat",
          "description": "polar repetition around an axis.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "count",
              "type": "f32",
              "description": "Number of repetitions around the circle."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Axis to repeat around (should be normalized)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfPolarRepeat(position: vec3<f32>, count: f32, axis: vec3<f32>) -> vec3<f32> {\n  let n = normalize(axis);\n  \n  // Project position onto axis\n  let axisProj = dot(position, n) * n;\n  let radial = position - axisProj;\n  \n  // Get angle in the plane perpendicular to axis\n  let radius = length(radial);\n  if (radius < 0.001) {\n    return position;\n  }\n  \n  let angle = atan2(radial.y, radial.x);\n  let sectorAngle = 6.28318530718 / count;\n  let snappedAngle = round(angle / sectorAngle) * sectorAngle;\n  \n  // Reconstruct position with snapped angle\n  let newRadial = radius * vec2<f32>(cos(snappedAngle), sin(snappedAngle));\n  \n  // This assumes axis is along Z - for general axis, need proper basis vectors\n  return axisProj + vec3<f32>(newRadial.x, newRadial.y, 0.0);\n}"
        },
        {
          "name": "sdfCylindricalRepeat",
          "description": "cylindrical coordinate repetition.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "angleRepeat",
              "type": "f32",
              "description": "Angular repetition count."
            },
            {
              "name": "heightRepeat",
              "type": "f32",
              "description": "Height repetition interval."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Cylindrical axis (should be normalized)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfCylindricalRepeat(position: vec3<f32>, angleRepeat: f32, heightRepeat: f32, axis: vec3<f32>) -> vec3<f32> {\n  let n = normalize(axis);\n  \n  // Project onto axis for height\n  let h = dot(position, n);\n  let radial = position - h * n;\n  \n  // Repeat in height\n  let newH = h - heightRepeat * round(h / heightRepeat);\n  \n  // Repeat in angle\n  let radius = length(radial);\n  if (radius < 0.001) {\n    return newH * n;\n  }\n  \n  let angle = atan2(radial.y, radial.x);\n  let sectorAngle = 6.28318530718 / angleRepeat;\n  let newAngle = angle - sectorAngle * round(angle / sectorAngle);\n  \n  let newRadial = radius * vec2<f32>(cos(newAngle), sin(newAngle));\n  \n  // This assumes axis is along Z - for general axis, need proper basis vectors\n  return newH * n + vec3<f32>(newRadial.x, newRadial.y, 0.0);\n}"
        },
        {
          "name": "sdfSphericalRepeat",
          "description": "spherical coordinate repetition.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "phiRepeat",
              "type": "f32",
              "description": "Azimuthal angle repetition count."
            },
            {
              "name": "thetaRepeat",
              "type": "f32",
              "description": "Polar angle repetition count."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfSphericalRepeat(position: vec3<f32>, phiRepeat: f32, thetaRepeat: f32) -> vec3<f32> {\n  let radius = length(position);\n  if (radius < 0.001) {\n    return position;\n  }\n  \n  // Convert to spherical coordinates\n  let theta = acos(clamp(position.z / radius, -1.0, 1.0));\n  let phi = atan2(position.y, position.x);\n  \n  // Repeat in spherical coordinates\n  let phiSector = 6.28318530718 / phiRepeat;\n  let thetaSector = 3.14159265359 / thetaRepeat;\n  \n  let newPhi = phi - phiSector * round(phi / phiSector);\n  let newTheta = theta - thetaSector * round(theta / thetaSector);\n  \n  // Convert back to Cartesian\n  let sinTheta = sin(newTheta);\n  return radius * vec3<f32>(\n    sinTheta * cos(newPhi),\n    sinTheta * sin(newPhi),\n    cos(newTheta)\n  );\n}"
        }
      ]
    },
    {
      "name": "SDF Modifiers",
      "slug": "sdf-modifiers",
      "description": "Deformation and domain manipulation functions for SDFs.",
      "functions": [
        {
          "name": "sdfTwist",
          "description": "a continuous rotation around an axis proportional to distance along that axis.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Twist angle in radians per unit distance."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Axis to twist around (should be normalized)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfTwist(position: vec3<f32>, angle: f32, axis: vec3<f32>) -> vec3<f32> {\n  // Normalize the axis\n  let axisNorm = normalize(axis);\n  \n  // Project position onto the twist axis\n  let proj = dot(position, axisNorm);\n  \n  // Calculate twist angle based on projection along axis\n  let twistAngle = proj * angle;\n  \n  // Get sin and cos of the twist angle\n  let s = sin(twistAngle);\n  let c = cos(twistAngle);\n  \n  // Calculate vector from axis (the part that will be rotated)\n  let axisProj = proj * axisNorm;\n  let fromAxis = position - axisProj;\n  \n  // Find a perpendicular vector for the rotation\n  let basis1 = normalize(fromAxis);\n  let basis2 = cross(axisNorm, basis1);\n  \n  // Rotate using the basis vectors\n  let rotated = axisProj + \n                basis1 * length(fromAxis) * c + \n                basis2 * length(fromAxis) * s;\n  \n  return rotated;\n}"
        },
        {
          "name": "sdfBend",
          "description": "geometry along a specified axis creating a smooth curve.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Bend angle in radians."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Axis normal to the bending plane."
            },
            {
              "name": "center",
              "type": "vec3<f32>",
              "description": "Center of the bend."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfBend(position: vec3<f32>, angle: f32, axis: vec3<f32>, center: vec3<f32>) -> vec3<f32> {\n  // Normalize the bend axis\n  let axisNorm = normalize(axis);\n  \n  // Translate position relative to bend center\n  let localPos = position - center;\n  \n  // Find perpendicular vectors to the bend axis to define the bend plane\n  var perpVec1: vec3<f32>;\n  if (abs(axisNorm.y) < 0.999) {\n    perpVec1 = normalize(cross(vec3<f32>(0.0, 1.0, 0.0), axisNorm));\n  } else {\n    perpVec1 = normalize(cross(vec3<f32>(1.0, 0.0, 0.0), axisNorm));\n  }\n  let perpVec2 = normalize(cross(axisNorm, perpVec1));\n  \n  // Project the position onto the perpendicular vectors\n  let proj1 = dot(localPos, perpVec1);\n  let proj2 = dot(localPos, perpVec2);\n  let axisProj = dot(localPos, axisNorm);\n  \n  // Calculate radius for the bend\n  let radius = proj1;\n  \n  // Calculate the angle based on the distance along the bend direction\n  let bendAngle = proj2 * angle;\n  \n  // Calculate the bent position using polar coordinates\n  let c = cos(bendAngle);\n  let s = sin(bendAngle);\n  \n  // Apply the transformation\n  let bentPos = center + \n                axisNorm * axisProj +\n                perpVec1 * (c * radius) +\n                perpVec2 * (s * radius);\n  \n  return bentPos;\n}"
        },
        {
          "name": "sdfTaper",
          "description": "a linear taper effect along an axis.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "amount",
              "type": "f32",
              "description": "Taper amount (0 = no taper, 1 = full taper)."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Taper axis direction."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height over which to apply the taper."
            },
            {
              "name": "offset",
              "type": "f32",
              "description": "Offset along the taper axis."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfTaper(position: vec3<f32>, amount: f32, axis: vec3<f32>, height: f32, offset: f32) -> vec3<f32> {\n  let axisNorm = normalize(axis);\n  \n  // Project position onto the taper axis\n  let axisPos = dot(position, axisNorm) - offset;\n  \n  // Calculate taper factor based on position along axis\n  let t = clamp(axisPos / height, 0.0, 1.0);\n  let taperFactor = 1.0 - amount * t;\n  \n  // Apply taper to the perpendicular components\n  let axisComponent = axisPos * axisNorm;\n  let perpComponent = position - dot(position, axisNorm) * axisNorm;\n  \n  return axisComponent + perpComponent * taperFactor;\n}"
        },
        {
          "name": "sdfDisplace",
          "description": "SDF using noise or other displacement functions.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to displace."
            },
            {
              "name": "amount",
              "type": "f32",
              "description": "Displacement amount."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Displacement frequency."
            },
            {
              "name": "seed",
              "type": "f32",
              "description": "Random seed for displacement."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "dependencies": [
            "hash3D"
          ],
          "wgslCode": "//! requires hash3D\nfn sdfDisplace(position: vec3<f32>, amount: f32, frequency: f32, seed: f32) -> vec3<f32> {\n  let noisePos = position * frequency + seed;\n  let displacement = hash3D(noisePos) * amount;\n  \n  return position + displacement;\n}"
        },
        {
          "name": "sdfDomainRepeat",
          "description": "domain repetition with optional warping for complex patterns.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "cellSize",
              "type": "vec3<f32>",
              "description": "Size of each repetition cell."
            },
            {
              "name": "warpAmount",
              "type": "f32",
              "description": "Amount of warping to apply."
            },
            {
              "name": "warpScale",
              "type": "f32",
              "description": "Scale of the warping effect."
            },
            {
              "name": "seed",
              "type": "f32",
              "description": "Random seed for warping."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "dependencies": [
            "warpNoise3D"
          ],
          "wgslCode": "//! requires warpNoise3D\nfn sdfDomainRepeat(position: vec3<f32>, cellSize: vec3<f32>, warpAmount: f32, warpScale: f32, seed: f32) -> vec3<f32> {\n  // Calculate warping for position\n  let warp = warpNoise3D(position * warpScale, seed) * warpAmount;\n  \n  // Apply warping to position\n  let warpedPos = position + warp;\n  \n  // Calculate repetition\n  return warpedPos - cellSize * round(warpedPos / cellSize);\n}"
        },
        {
          "name": "sdfFiniteRepeat",
          "description": "finite repetition with specified count along each axis.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "spacing",
              "type": "vec3<f32>",
              "description": "Spacing between repetitions."
            },
            {
              "name": "count",
              "type": "vec3<f32>",
              "description": "Number of repetitions along each axis."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfFiniteRepeat(position: vec3<f32>, spacing: vec3<f32>, count: vec3<f32>) -> vec3<f32> {\n  let id = clamp(round(position / spacing), -count * 0.5, count * 0.5);\n  return position - spacing * id;\n}"
        },
        {
          "name": "sdfInfiniteRepeat",
          "description": "infinite repetition along all axes.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "spacing",
              "type": "vec3<f32>",
              "description": "Spacing between repetitions."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "dependencies": [],
          "wgslCode": "fn sdfInfiniteRepeat(position: vec3<f32>, spacing: vec3<f32>) -> vec3<f32> {\n  return position - spacing * round(position / spacing);\n}"
        }
      ]
    },
    {
      "name": "SDF Utilities",
      "slug": "sdf-utilities",
      "description": "Utility functions for rendering and post-processing SDFs.",
      "functions": [
        {
          "name": "sdfToSolid",
          "description": "a signed distance field to a solid boolean value.",
          "params": [
            {
              "name": "signedDistance",
              "type": "f32",
              "description": "Signed distance field value."
            },
            {
              "name": "threshold",
              "type": "f32",
              "description": "Threshold for solid determination."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "if solid, 0.0 if not (as f32 for compatibility)."
          },
          "dependencies": [],
          "wgslCode": "fn sdfToSolid(signedDistance: f32, threshold: f32) -> f32 {\n  return select(0.0, 1.0, signedDistance <= threshold);\n}"
        },
        {
          "name": "sdfToStroke",
          "description": "a signed distance field to a stroke/outline.",
          "params": [
            {
              "name": "signedDistance",
              "type": "f32",
              "description": "Signed distance field value."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Stroke thickness."
            },
            {
              "name": "center",
              "type": "f32",
              "description": "Center distance for the stroke."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "if within stroke, 0.0 if not."
          },
          "dependencies": [],
          "wgslCode": "fn sdfToStroke(signedDistance: f32, thickness: f32, center: f32) -> f32 {\n  return select(0.0, 1.0, abs(signedDistance - center) <= thickness * 0.5);\n}"
        },
        {
          "name": "sdfToSmoothSolid",
          "description": "a signed distance field to a smooth solid with anti-aliasing.",
          "params": [
            {
              "name": "signedDistance",
              "type": "f32",
              "description": "Signed distance field value."
            },
            {
              "name": "threshold",
              "type": "f32",
              "description": "Threshold for solid determination."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for anti-aliasing."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0.0 and 1.0."
          },
          "dependencies": [],
          "wgslCode": "fn sdfToSmoothSolid(signedDistance: f32, threshold: f32, smoothing: f32) -> f32 {\n  return 1.0 - smoothstep(threshold - smoothing, threshold + smoothing, signedDistance);\n}"
        },
        {
          "name": "sdfToSmoothStroke",
          "description": "a signed distance field to a smooth stroke with anti-aliasing.",
          "params": [
            {
              "name": "signedDistance",
              "type": "f32",
              "description": "Signed distance field value."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Stroke thickness."
            },
            {
              "name": "center",
              "type": "f32",
              "description": "Center distance for the stroke."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for anti-aliasing."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "stroke value between 0.0 and 1.0."
          },
          "dependencies": [],
          "wgslCode": "fn sdfToSmoothStroke(signedDistance: f32, thickness: f32, center: f32, smoothing: f32) -> f32 {\n  let distance = abs(signedDistance - center);\n  return 1.0 - smoothstep(thickness * 0.5 - smoothing, thickness * 0.5 + smoothing, distance);\n}"
        }
      ]
    }
  ]
}