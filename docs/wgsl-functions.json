{
  "meta": {
    "generatedAt": "2025-07-17T12:05:01.354Z",
    "totalFunctions": 87,
    "totalCategories": 10
  },
  "categories": [
    {
      "name": "Math & Utility",
      "slug": "math---utility",
      "description": "Mathematical functions and general utilities for shader calculations.",
      "functions": [
        {
          "name": "elasticWave",
          "description": "an elastic wave with exponential decay and sinusoidal oscillation.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position along the wave."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude multiplier."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "decay",
              "type": "f32",
              "description": "Exponential decay factor."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset for the wave."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn elasticWave(x: f32, amplitude: f32, frequency: f32, decay: f32, phase: f32) -> f32 {\n  let d = max(0.001, decay);\n  let decayTerm = exp(-d * x);\n  let oscTerm = sin(frequency * x * 6.28318 + phase);\n  return amplitude * decayTerm * oscTerm;\n}"
        },
        {
          "name": "smoothStep",
          "description": "interpolation between two values with smooth acceleration and deceleration.",
          "params": [
            {
              "name": "edge0",
              "type": "f32",
              "description": "Lower edge of interpolation range."
            },
            {
              "name": "edge1",
              "type": "f32",
              "description": "Upper edge of interpolation range."
            },
            {
              "name": "x",
              "type": "f32",
              "description": "Input value to interpolate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "interpolated value between 0 and 1."
          },
          "wgslCode": "fn smoothStep(edge0: f32, edge1: f32, x: f32) -> f32 {\n  let t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  return t * t * (3.0 - 2.0 * t);\n}"
        },
        {
          "name": "rotate2D",
          "description": "a 2D vector by a given angle.",
          "params": [
            {
              "name": "v",
              "type": "vec2<f32>",
              "description": "Input 2D vector to rotate."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Rotation angle in radians."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "2D vector."
          },
          "wgslCode": "fn rotate2D(v: vec2<f32>, angle: f32) -> vec2<f32> {\n  let c = cos(angle);\n  let s = sin(angle);\n  return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}"
        },
        {
          "name": "exponentialRamp",
          "description": "an exponential ramp function with derivative.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "base",
              "type": "f32",
              "description": "Exponential base."
            },
            {
              "name": "scale",
              "type": "f32",
              "description": "Scale factor."
            },
            {
              "name": "offset",
              "type": "f32",
              "description": "Vertical offset."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative."
          },
          "wgslCode": "fn exponentialRamp(x: f32, base: f32, scale: f32, offset: f32) -> vec2<f32> {\n  // Ensure base is positive and not 1 (which would make it linear)\n  let b = select(base, 2.71828, abs(base - 1.0) < 0.001);\n  \n  // Calculate the exponential function\n  let result = scale * pow(b, x) + offset;\n  \n  // Calculate the derivative\n  let derivative = scale * pow(b, x) * log(b);\n  \n  return vec2<f32>(result, derivative);\n}"
        },
        {
          "name": "logisticCurve",
          "description": "a logistic (S-curve) function with derivative.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "midpoint",
              "type": "f32",
              "description": "Curve midpoint (inflection point)."
            },
            {
              "name": "steepness",
              "type": "f32",
              "description": "Curve steepness factor."
            },
            {
              "name": "min",
              "type": "f32",
              "description": "Minimum output value."
            },
            {
              "name": "max",
              "type": "f32",
              "description": "Maximum output value."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative."
          },
          "wgslCode": "fn logisticCurve(x: f32, midpoint: f32, steepness: f32, minValue: f32, maxValue: f32) -> vec2<f32> {\n  // Scale factor for steepness\n  let k = max(0.001, steepness);\n  \n  // Shift x relative to midpoint\n  let z = -k * (x - midpoint);\n  \n  // Calculate the exponent\n  let expTerm = exp(z);\n  \n  // Calculate the logistic function value\n  let logistic = 1.0 / (1.0 + expTerm);\n  \n  // Scale to min-max range\n  let range = maxValue - minValue;\n  let value = minValue + range * logistic;\n  \n  // Calculate the derivative\n  let derivative = range * k * expTerm / ((1.0 + expTerm) * (1.0 + expTerm));\n  \n  return vec2<f32>(value, derivative);\n}"
        },
        {
          "name": "stepSequence",
          "description": "a stepped sequence with optional smoothing between steps.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "steps",
              "type": "f32",
              "description": "Number of steps in the sequence."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor between steps (0-1)."
            },
            {
              "name": "minValue",
              "type": "f32",
              "description": "Minimum output value."
            },
            {
              "name": "maxValue",
              "type": "f32",
              "description": "Maximum output value."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and current step index."
          },
          "wgslCode": "fn stepSequence(x: f32, steps: f32, smoothing: f32, minValue: f32, maxValue: f32) -> vec2<f32> {\n  // Ensure at least 1 step and positive smoothing\n  let numSteps = max(1.0, floor(steps));\n  let smoothFactor = max(0.0, smoothing);\n  \n  // Normalize x to 0-1 range\n  let normalizedX = fract(x);\n  \n  // Calculate the size of each step\n  let stepSize = 1.0 / numSteps;\n  \n  // Calculate the current step (0 to numSteps-1)\n  let currentStep = floor(normalizedX * numSteps);\n  let nextStep = fract(currentStep + 1.0);\n  \n  // Calculate progress within the current step\n  let stepProgress = fract(normalizedX * numSteps);\n  \n  // Calculate the progress values for current and next steps\n  let currentStepValue = currentStep / (numSteps - 1.0);\n  \n  // Prepare next step value, handle the last step case\n  var nextStepValue: f32 = 0.0;\n  if (currentStep >= numSteps - 1.0) {\n    nextStepValue = 1.0;\n  } else {\n    nextStepValue = nextStep / (numSteps - 1.0);\n  }\n  \n  // Apply smoothing between steps if needed\n  var result: f32 = 0.0;\n  \n  if (smoothFactor > 0.0 && stepProgress > (1.0 - smoothFactor) && numSteps > 1.0) {\n    // Calculate smoothing factor\n    let t = (stepProgress - (1.0 - smoothFactor)) / smoothFactor;\n    \n    // Smoothstep for better transition\n    let smoothT = t * t * (3.0 - 2.0 * t);\n    \n    // Interpolate between current and next step\n    result = mix(currentStepValue, nextStepValue, smoothT);\n  } else {\n    result = currentStepValue;\n  }\n  \n  // Scale to min-max range\n  let range = maxValue - minValue;\n  let finalResult = minValue + result * range;\n  \n  return vec2<f32>(finalResult, currentStep);\n}"
        }
      ]
    },
    {
      "name": "Noise & Procedural",
      "slug": "noise---procedural",
      "description": "Noise generation and procedural pattern functions for textures and effects.",
      "functions": [
        {
          "name": "hash22",
          "description": "a 2D hash from a 2D input vector for procedural generation.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D vector to hash."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "result as 2D vector."
          },
          "wgslCode": "fn hash22(p: vec2<f32>) -> vec2<f32> {\n  var p3 = fract(vec3<f32>(p.xyx) * vec3<f32>(0.1031, 0.1030, 0.0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}"
        },
        {
          "name": "noise2D",
          "description": "2D Perlin-style noise for procedural textures and patterns.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value typically in range [-1, 1]."
          },
          "wgslCode": "fn noise2D(p: vec2<f32>) -> f32 {\n  let i = floor(p);\n  let f = fract(p);\n  let u = f * f * (3.0 - 2.0 * f);\n  return mix(\n    mix(dot(hash22(i + vec2<f32>(0.0, 0.0)), f - vec2<f32>(0.0, 0.0)),\n        dot(hash22(i + vec2<f32>(1.0, 0.0)), f - vec2<f32>(1.0, 0.0)), u.x),\n    mix(dot(hash22(i + vec2<f32>(0.0, 1.0)), f - vec2<f32>(0.0, 1.0)),\n        dot(hash22(i + vec2<f32>(1.0, 1.0)), f - vec2<f32>(1.0, 1.0)), u.x), u.y);\n}"
        },
        {
          "name": "fbm",
          "description": "Brownian Motion - combines multiple octaves of noise for complex patterns.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            },
            {
              "name": "octaves",
              "type": "i32",
              "description": "Number of noise octaves to combine."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value."
          },
          "wgslCode": "fn fbm(p: vec2<f32>, octaves: i32) -> f32 {\n  var value = 0.0;\n  var amplitude = 0.5;\n  var frequency = 1.0;\n  for (var i = 0; i < octaves; i++) {\n    value += amplitude * noise2D(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}"
        },
        {
          "name": "hash1D",
          "description": "a 1D hash value from an input value for noise generation.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "Input value to hash."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "wgslCode": "fn hash1D(p: f32) -> f32 {\n  // Convert to integer and apply bit manipulation\n  let x = bitcast<u32>(p + 123.456789);\n  var h = x;\n  \n  // Wang hash function\n  h = (h ^ 61u) ^ (h >> 16u);\n  h = h + (h << 3u);\n  h = h ^ (h >> 4u);\n  h = h * 0x27d4eb2du;\n  h = h ^ (h >> 15u);\n  \n  // Convert back to float and normalize\n  return f32(h) / 4294967296.0;\n}"
        },
        {
          "name": "hash31",
          "description": "a 1D hash value from a 3D input vector.",
          "params": [
            {
              "name": "p",
              "type": "vec3<f32>",
              "description": "Input 3D vector to hash."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "wgslCode": "fn hash31(p: vec3<f32>) -> f32 {\n  var p3 = fract(p * vec3<f32>(0.1031, 0.1030, 0.0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}"
        },
        {
          "name": "hash3D",
          "description": "a 3D hash vector from a 3D input for displacement effects.",
          "params": [
            {
              "name": "p",
              "type": "vec3<f32>",
              "description": "Input 3D vector to hash."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "result as 3D vector with values between -1 and 1."
          },
          "wgslCode": "fn hash3D(p: vec3<f32>) -> vec3<f32> {\n  var p3 = fract(p * vec3<f32>(0.1031, 0.1030, 0.0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx) * p3.zyx) * 2.0 - 1.0;\n}"
        },
        {
          "name": "noise3D",
          "description": "3D noise using trilinear interpolation.",
          "params": [
            {
              "name": "x",
              "type": "vec3<f32>",
              "description": "Input 3D position for noise generation."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "wgslCode": "fn noise3D(x: vec3<f32>) -> f32 {\n  let p = floor(x);\n  let f = fract(x);\n  \n  return mix(\n    mix(\n      mix(hash31(p), \n          hash31(p + vec3<f32>(1.0, 0.0, 0.0)), \n          f.x),\n      mix(hash31(p + vec3<f32>(0.0, 1.0, 0.0)), \n          hash31(p + vec3<f32>(1.0, 1.0, 0.0)), \n          f.x),\n      f.y),\n    mix(\n      mix(hash31(p + vec3<f32>(0.0, 0.0, 1.0)), \n          hash31(p + vec3<f32>(1.0, 0.0, 1.0)), \n          f.x),\n      mix(hash31(p + vec3<f32>(0.0, 1.0, 1.0)), \n          hash31(p + vec3<f32>(1.0, 1.0, 1.0)), \n          f.x),\n      f.y),\n    f.z);\n}"
        },
        {
          "name": "warpNoise3D",
          "description": "3D warping noise using fractal Brownian motion.",
          "params": [
            {
              "name": "x",
              "type": "vec3<f32>",
              "description": "Input 3D position."
            },
            {
              "name": "seedVal",
              "type": "f32",
              "description": "Random seed for variation."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "warp vector with values between -1 and 1."
          },
          "wgslCode": "fn warpNoise3D(x: vec3<f32>, seedVal: f32) -> vec3<f32> {\n  var p = x + seedVal;\n  var nx = 0.0;\n  var ny = 0.0;\n  var nz = 0.0;\n  var w = 0.5;\n  \n  for (var i = 0; i < 3; i++) {\n    nx += w * noise3D(p);\n    ny += w * noise3D(p + vec3<f32>(13.5, 41.3, 17.8));\n    nz += w * noise3D(p + vec3<f32>(31.2, 23.7, 11.9));\n    p *= 2.0;\n    w *= 0.5;\n  }\n  \n  return vec3<f32>(nx, ny, nz) * 2.0 - 1.0;\n}"
        }
      ]
    },
    {
      "name": "Signed Distance Fields",
      "slug": "signed-distance-fields",
      "description": "SDF functions for procedural geometry and ray marching techniques.",
      "functions": [
        {
          "name": "sdfCircle",
          "description": "distance function for a circle.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Point to evaluate distance from."
            },
            {
              "name": "r",
              "type": "f32",
              "description": "Circle radius."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to circle surface (negative inside, positive outside)."
          },
          "wgslCode": "fn sdfCircle(p: vec2<f32>, r: f32) -> f32 {\n  return length(p) - r;\n}"
        },
        {
          "name": "sdfBox",
          "description": "distance function for a rectangular box.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Point to evaluate distance from."
            },
            {
              "name": "b",
              "type": "vec2<f32>",
              "description": "Box half-dimensions (width/2, height/2)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to box surface (negative inside, positive outside)."
          },
          "wgslCode": "fn sdfBox(p: vec2<f32>, b: vec2<f32>) -> f32 {\n  let d = abs(p) - b;\n  return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n}"
        },
        {
          "name": "sdfUnion",
          "description": "two SDFs using union operation (closest surface).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from first shape."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from second shape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing union of both shapes."
          },
          "wgslCode": "fn sdfUnion(d1: f32, d2: f32) -> f32 {\n  return min(d1, d2);\n}"
        },
        {
          "name": "sdfIntersection",
          "description": "two SDFs using intersection operation (overlapping area only).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from first shape."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from second shape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing intersection of both shapes."
          },
          "wgslCode": "fn sdfIntersection(d1: f32, d2: f32) -> f32 {\n  return max(d1, d2);\n}"
        },
        {
          "name": "sdfSubtraction",
          "description": "two SDFs using subtraction operation (first shape minus second).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from shape to subtract from."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from shape to subtract."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing first shape with second subtracted."
          },
          "wgslCode": "fn sdfSubtraction(d1: f32, d2: f32) -> f32 {\n  return max(-d1, d2);\n}"
        },
        {
          "name": "boxFrameSDF",
          "description": "a signed distance field for a 3D box frame (hollow box).",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "vec3<f32>",
              "description": "Half-extents of the box."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Wall thickness of the frame."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the box frame surface."
          },
          "wgslCode": "fn boxFrameSDF(position: vec3<f32>, size: vec3<f32>, thickness: f32) -> f32 {\n  let q = abs(position) - size;\n  let w = abs(q + thickness) - thickness;\n  return min(min(\n    length(max(vec3<f32>(q.x, w.y, w.z), vec3<f32>(0.0))) + min(max(q.x, max(w.y, w.z)), 0.0),\n    length(max(vec3<f32>(w.x, q.y, w.z), vec3<f32>(0.0))) + min(max(w.x, max(q.y, w.z)), 0.0)),\n    length(max(vec3<f32>(w.x, w.y, q.z), vec3<f32>(0.0))) + min(max(w.x, max(w.y, q.z)), 0.0));\n}"
        },
        {
          "name": "cappedTorusSDF",
          "description": "a signed distance field for a capped torus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "majorRadius",
              "type": "f32",
              "description": "Major radius of the torus."
            },
            {
              "name": "minorRadius",
              "type": "f32",
              "description": "Minor radius of the torus."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Cap angle in radians."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the capped torus surface."
          },
          "wgslCode": "fn cappedTorusSDF(position: vec3<f32>, majorRadius: f32, minorRadius: f32, angle: f32) -> f32 {\n  let sc = vec2<f32>(sin(angle), cos(angle));\n  let q = vec3<f32>(abs(position.x), position.y, position.z);\n  let k = select(\n    length(q.xy), \n    dot(q.xy, sc),\n    sc.y * q.x > sc.x * q.y\n  );\n  return sqrt(dot(q, q) + \n              majorRadius * majorRadius - \n              2.0 * majorRadius * k) - \n              minorRadius;\n}"
        },
        {
          "name": "capsuleSDF",
          "description": "a signed distance field for a capsule (cylinder with rounded caps).",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the capsule."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylindrical portion."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the capsule surface."
          },
          "wgslCode": "fn capsuleSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let d = abs(length(position.xz)) - radius;\n  let p = vec2<f32>(d, abs(position.y) - height * 0.5);\n  return length(max(p, vec2<f32>(0.0))) + min(max(p.x, p.y), 0.0) - radius;\n}"
        },
        {
          "name": "coneSDF",
          "description": "a signed distance field for a cone.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Base radius of the cone."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cone."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the cone surface."
          },
          "wgslCode": "fn coneSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let q = vec2<f32>(length(position.xz), position.y);\n  let h = height;\n  let r = radius;\n  \n  // Calculate distance\n  let d1 = -q.y - h;\n  let d2 = max(q.x * h - q.y * r, q.y * h + q.x * r);\n  \n  return length(max(vec2<f32>(d1, d2), vec2<f32>(0.0))) + min(max(d1, d2), 0.0);\n}"
        },
        {
          "name": "cylinderSDF",
          "description": "a signed distance field for a cylinder.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the cylinder."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylinder."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the cylinder surface."
          },
          "wgslCode": "fn cylinderSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let d = vec2<f32>(length(position.xz), abs(position.y)) - vec2<f32>(radius, height * 0.5);\n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0)));\n}"
        },
        {
          "name": "ellipsoidSDF",
          "description": "a signed distance field for an ellipsoid.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "vec3<f32>",
              "description": "Radii along each axis."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the ellipsoid surface."
          },
          "wgslCode": "fn ellipsoidSDF(position: vec3<f32>, radius: vec3<f32>) -> f32 {\n  let k0 = length(position / radius);\n  let k1 = length(position / (radius * radius));\n  return k0 * (k0 - 1.0) / k1;\n}"
        },
        {
          "name": "gyroidSDF",
          "description": "a signed distance field for a gyroid surface.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "scale",
              "type": "f32",
              "description": "Scale factor for the gyroid pattern."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Thickness of the gyroid surface."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the gyroid surface."
          },
          "wgslCode": "fn gyroidSDF(position: vec3<f32>, scale: f32, thickness: f32) -> f32 {\n  let p = position * scale;\n  return (abs(dot(sin(p), cos(p.zxy))) - thickness) / scale;\n}"
        },
        {
          "name": "hexagonalPrismSDF",
          "description": "a signed distance field for a hexagonal prism.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the hexagon."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the prism."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the hexagonal prism surface."
          },
          "wgslCode": "fn hexagonalPrismSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  // Project into 2D\n  var p = abs(position);\n  let k = vec3<f32>(-0.866025404, 0.5, 0.577350269);\n  \n  // Hexagon in xy-plane\n  p = vec3<f32>(p.x + p.y * k.x, p.y * k.y, p.z);\n  p = vec3<f32>(p.x - min(p.x, p.y), p.y, p.z);\n  let d = vec2<f32>(length(vec2<f32>(p.x, p.y - radius * k.z)) - radius, abs(p.z) - height * 0.5);\n  \n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0)));\n}"
        },
        {
          "name": "icosahedronSDF",
          "description": "a signed distance field for an icosahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the icosahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the icosahedron surface."
          },
          "wgslCode": "fn icosahedronSDF(position: vec3<f32>, size: f32) -> f32 {\n  var p = position;\n  let s = size;\n  \n  // Constants for icosahedron\n  let phi = 1.618033988749895;\n  let a = s;\n  let b = s * phi;\n  \n  // Compute distance to icosahedron\n  p = abs(p / s);\n  let d = p.x * p.y * p.z;\n  let m = max(max(p.x, p.y), p.z);\n  let n = min(min(p.x, p.y), p.z);\n  let mid = p.x + p.y + p.z - m - n;\n  \n  // Calculate the signed distance\n  let q = select(mid, d, m < phi * n);\n  return (length(p) - phi) * s;\n}"
        },
        {
          "name": "juliaSDF",
          "description": "a signed distance field for a 4D Julia set fractal.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "c",
              "type": "vec4<f32>",
              "description": "Julia set parameter (quaternion)."
            },
            {
              "name": "iterations",
              "type": "f32",
              "description": "Maximum number of iterations."
            },
            {
              "name": "bailout",
              "type": "f32",
              "description": "Bailout radius for iteration escape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the Julia set surface."
          },
          "wgslCode": "fn juliaSDF(position: vec3<f32>, c: vec4<f32>, iterations: f32, bailout: f32) -> f32 {\n  var z = vec4<f32>(position, 0.0);\n  var dz = vec4<f32>(1.0, 0.0, 0.0, 0.0);\n  var m = dot(z, z);\n  var i = 0;\n  \n  // Julia set iteration\n  for (i = 0; i < i32(iterations) && m < bailout * bailout; i += 1) {\n    // Quaternion multiplication for dz = 2.0 * z * dz\n    dz = 2.0 * vec4<f32>(\n      z.x * dz.x - z.y * dz.y - z.z * dz.z - z.w * dz.w,\n      z.x * dz.y + z.y * dz.x + z.z * dz.w - z.w * dz.z,\n      z.x * dz.z - z.y * dz.w + z.z * dz.x + z.w * dz.y,\n      z.x * dz.w + z.y * dz.z - z.z * dz.y + z.w * dz.x\n    );\n    \n    // Quaternion multiplication for z = z * z + c\n    z = vec4<f32>(\n      z.x * z.x - z.y * z.y - z.z * z.z - z.w * z.w,\n      z.x * z.y + z.y * z.x + z.z * z.w - z.w * z.z,\n      z.x * z.z - z.y * z.w + z.z * z.x + z.w * z.y,\n      z.x * z.w + z.y * z.z - z.z * z.y + z.w * z.x\n    ) + c;\n    \n    m = dot(z, z);\n  }\n  \n  // Compute the distance\n  let dist = 0.5 * log(m) * sqrt(m) / length(dz);\n  return dist;\n}"
        },
        {
          "name": "octahedronSDF",
          "description": "a signed distance field for an octahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the octahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the octahedron surface."
          },
          "wgslCode": "fn octahedronSDF(position: vec3<f32>, size: f32) -> f32 {\n  let p = abs(position);\n  let m = p.x + p.y + p.z - size;\n  \n  // Calculate the distance\n  var q: vec3<f32>;\n  if (3.0 * p.x < m) {\n    q = p;\n  } else if (3.0 * p.y < m) {\n    q = vec3<f32>(p.x, p.z, p.y);\n  } else if (3.0 * p.z < m) {\n    q = vec3<f32>(p.x, p.y, p.z);\n  } else {\n    q = p;\n  }\n  \n  let k = clamp(0.5 * (q.z - q.y + size), 0.0, size);\n  return length(vec3<f32>(q.x, q.y - size + k, q.z - k));\n}"
        },
        {
          "name": "planeSDF",
          "description": "a signed distance field for an infinite plane.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "normal",
              "type": "vec3<f32>",
              "description": "Normal vector of the plane (should be normalized)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the plane surface."
          },
          "wgslCode": "fn planeSDF(position: vec3<f32>, normal: vec3<f32>) -> f32 {\n  let n = normalize(normal);\n  return dot(position, n);\n}"
        },
        {
          "name": "pyramidSDF",
          "description": "a signed distance field for a pyramid.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Base size of the pyramid."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the pyramid."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the pyramid surface."
          },
          "wgslCode": "fn pyramidSDF(position: vec3<f32>, size: f32, height: f32) -> f32 {\n  // Normalize position\n  var p = position;\n  let h = height;\n  let m2 = h * h + size * size;\n  \n  // Project into 2D\n  let q = abs(p);\n  p.y -= h;\n  p.y = max(p.y, 0.0);\n  \n  // Distance calculation\n  var d: f32;\n  if (max(q.x, q.z) < size) {\n    d = length(vec2<f32>(length(p.xz), p.y)) - sqrt(m2);\n  } else {\n    d = length(vec2<f32>(length(max(abs(p.xz) - vec2<f32>(size), vec2<f32>(0.0))), p.y));\n  }\n  \n  // Account for position below base\n  d = select(d, length(p) - sqrt(m2), p.y < 0.0);\n  \n  return d;\n}"
        },
        {
          "name": "rhombusSDF",
          "description": "a signed distance field for a rhombus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "dimensions",
              "type": "vec3<f32>",
              "description": "Dimensions of the rhombus."
            },
            {
              "name": "sharpness",
              "type": "f32",
              "description": "Sharpness factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rhombus surface."
          },
          "wgslCode": "fn rhombusSDF(position: vec3<f32>, dimensions: vec3<f32>, sharpness: f32) -> f32 {\n  var p = abs(position);\n  let b = dimensions;\n  let e = sharpness;\n  \n  // Calculate distance to rhombus\n  p = p - b;\n  let q = abs(p.x + p.y + p.z) + e;\n  let h = max(vec3<f32>(q) - vec3<f32>(e), vec3<f32>(0.0));\n  \n  return min(max(p.x, max(p.y, p.z)), 0.0) + length(h);\n}"
        },
        {
          "name": "roundBoxSDF",
          "description": "a signed distance field for a rounded box.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "vec3<f32>",
              "description": "Half-extents of the box."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Rounding radius for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded box surface."
          },
          "wgslCode": "fn roundBoxSDF(position: vec3<f32>, size: vec3<f32>, radius: f32) -> f32 {\n  let q = abs(position) - size;\n  return length(max(q, vec3<f32>(0.0))) + \n         min(max(q.x, max(q.y, q.z)), 0.0) - \n         radius;\n}"
        },
        {
          "name": "roundedConeSDF",
          "description": "a signed distance field for a rounded cone.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius1",
              "type": "f32",
              "description": "Bottom radius of the cone."
            },
            {
              "name": "radius2",
              "type": "f32",
              "description": "Top radius of the cone."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cone."
            },
            {
              "name": "roundness",
              "type": "f32",
              "description": "Rounding factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded cone surface."
          },
          "wgslCode": "fn roundedConeSDF(position: vec3<f32>, radius1: f32, radius2: f32, height: f32, roundness: f32) -> f32 {\n  // Calculate distances\n  let p = position;\n  let r1 = radius1 - roundness;\n  let r2 = radius2 - roundness;\n  let h = height;\n  \n  // Squared distance from axis\n  let q = length(p.xz);\n  \n  // Project into 2D space\n  let k1 = (r2 - r1) / h;\n  let k2 = h / (r1 - r2);\n  let projected = vec2<f32>(q - r1 + r1 * (p.y / h) * (r1 - r2) / r1, p.y - h);\n  let ca = p.y * k1 - q;\n  let cb = p.y - r1 * k2 + q * k2;\n  \n  var s: f32;\n  if (ca < 0.0 && projected.y < 0.0) {\n    s = length(projected) - roundness;\n  } else if (ca > 0.0 && cb < 0.0) {\n    s = -ca - roundness;\n  } else {\n    s = length(vec2<f32>(max(ca, 0.0), max(projected.y, 0.0))) - roundness;\n  }\n  \n  return s;\n}"
        },
        {
          "name": "roundedCylinderSDF",
          "description": "a signed distance field for a rounded cylinder.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the cylinder."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylinder."
            },
            {
              "name": "roundness",
              "type": "f32",
              "description": "Rounding factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded cylinder surface."
          },
          "wgslCode": "fn roundedCylinderSDF(position: vec3<f32>, radius: f32, height: f32, roundness: f32) -> f32 {\n  // Calculate distances\n  let radiusOffset = radius - roundness;\n  let heightOffset = height * 0.5 - roundness;\n  \n  // Generate rounded cylinder\n  let d = vec2<f32>(length(position.xz) - radiusOffset, abs(position.y) - heightOffset);\n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0))) - roundness;\n}"
        },
        {
          "name": "sphereSDF",
          "description": "a signed distance field for a sphere.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the sphere."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the sphere surface."
          },
          "wgslCode": "fn sphereSDF(position: vec3<f32>, radius: f32) -> f32 {\n  return length(position) - radius;\n}"
        },
        {
          "name": "tetrahedronSDF",
          "description": "a signed distance field for a tetrahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the tetrahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the tetrahedron surface."
          },
          "wgslCode": "fn tetrahedronSDF(position: vec3<f32>, size: f32) -> f32 {\n  var p = position;\n  let s = size;\n  \n  // Set initial values\n  let signVal = sign(p.x + p.y + p.z);\n  p.x = abs(p.x);\n  p.y = abs(p.y);\n  p.z = abs(p.z);\n  \n  // Calculate the distance\n  if (p.x < p.y) {\n    let t = p.x;\n    p.x = p.y;\n    p.y = t;\n  }\n  if (p.x < p.z) {\n    let t = p.x;\n    p.x = p.z;\n    p.z = t;\n  }\n  if (p.y < p.z) {\n    let t = p.y;\n    p.y = p.z;\n    p.z = t;\n  }\n  \n  let k = clamp((p.x + p.z - p.y) * 0.5, 0.0, p.z);\n  return signVal * (length(vec3<f32>(p.x, p.y - s, p.z - k)) - s);\n}"
        },
        {
          "name": "torusSDF",
          "description": "a signed distance field for a torus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "majorRadius",
              "type": "f32",
              "description": "Major radius of the torus."
            },
            {
              "name": "minorRadius",
              "type": "f32",
              "description": "Minor radius of the torus."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the torus surface."
          },
          "wgslCode": "fn torusSDF(position: vec3<f32>, majorRadius: f32, minorRadius: f32) -> f32 {\n  let q = vec2<f32>(length(position.xz) - majorRadius, position.y);\n  return length(q) - minorRadius;\n}"
        },
        {
          "name": "triangularPrismSDF",
          "description": "a signed distance field for a triangular prism.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the triangular base."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the prism."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the triangular prism surface."
          },
          "wgslCode": "fn triangularPrismSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  var q = abs(position);\n  \n  // Triangle distance in xy-plane\n  let k = sqrt(3.0);\n  q.x = abs(q.x - q.y * k * 0.5);\n  q.y = q.y * 0.866025404 + q.x * 0.5;\n  \n  // Combine with z distance\n  let d1 = vec2<f32>(q.x - radius, q.y);\n  let d2 = vec2<f32>(q.y - radius, q.x);\n  let d = min(d1, d2);\n  \n  // Account for height\n  let h = height * 0.5;\n  let dz = q.z - h;\n  let dz2 = max(dz, 0.0);\n  \n  return length(max(vec2<f32>(max(d.x, 0.0), dz2), vec2<f32>(0.0))) + min(max(d.x, dz), 0.0);\n}"
        }
      ]
    },
    {
      "name": "Color & Graphics",
      "slug": "color---graphics",
      "description": "Color space conversion and palette generation functions.",
      "functions": [
        {
          "name": "palette",
          "description": "colors using cosine-based palette function for smooth color gradients.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (typically 0-1) for palette lookup."
            },
            {
              "name": "a",
              "type": "vec3<f32>",
              "description": "Offset values for RGB channels."
            },
            {
              "name": "b",
              "type": "vec3<f32>",
              "description": "Amplitude values for RGB channels."
            },
            {
              "name": "c",
              "type": "vec3<f32>",
              "description": "Frequency values for RGB channels."
            },
            {
              "name": "d",
              "type": "vec3<f32>",
              "description": "Phase values for RGB channels."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "RGB color."
          },
          "wgslCode": "fn palette(t: f32, a: vec3<f32>, b: vec3<f32>, c: vec3<f32>, d: vec3<f32>) -> vec3<f32> {\n  return a + b * cos(6.28318 * (c * t + d));\n}"
        },
        {
          "name": "linearToSrgb",
          "description": "linear RGB color values to sRGB color space.",
          "params": [
            {
              "name": "color",
              "type": "vec3<f32>",
              "description": "Linear RGB color values."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "color values."
          },
          "wgslCode": "fn linearToSrgb(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3(1.0 / 2.2));\n}"
        },
        {
          "name": "srgbToLinear",
          "description": "sRGB color values to linear RGB color space.",
          "params": [
            {
              "name": "color",
              "type": "vec3<f32>",
              "description": "sRGB color values."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "RGB color values."
          },
          "wgslCode": "fn srgbToLinear(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3(2.2));\n}"
        },
        {
          "name": "hue2rgb",
          "description": "function for HSL to RGB conversion - converts hue component to RGB.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "First HSL conversion parameter."
            },
            {
              "name": "q",
              "type": "f32",
              "description": "Second HSL conversion parameter."
            },
            {
              "name": "t",
              "type": "f32",
              "description": "Hue value (adjusted)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "component value."
          },
          "wgslCode": "fn hue2rgb(p: f32, q: f32, t: f32) -> f32 {\n  var t_adj = t;\n  if (t_adj < 0.0) { t_adj += 1.0; }\n  if (t_adj > 1.0) { t_adj -= 1.0; }\n  if (t_adj < 1.0 / 6.0) { return p + (q - p) * 6.0 * t_adj; }\n  if (t_adj < 1.0 / 2.0) { return q; }\n  if (t_adj < 2.0 / 3.0) { return p + (q - p) * (2.0 / 3.0 - t_adj) * 6.0; }\n  return p;\n}"
        },
        {
          "name": "hslToRgb",
          "description": "HSL (Hue, Saturation, Lightness) color to RGB.",
          "params": [
            {
              "name": "hsl",
              "type": "vec3<f32>",
              "description": "HSL color values (hue: 0-1, saturation: 0-1, lightness: 0-1)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "color values."
          },
          "wgslCode": "fn hslToRgb(hsl: vec3<f32>) -> vec3<f32> {\n  let h = hsl.x;\n  let s = hsl.y;\n  let l = hsl.z;\n  \n  if (s == 0.0) {\n    return vec3(l); // achromatic\n  }\n  \n  let q = select(l * (1.0 + s), l + s - l * s, l < 0.5);\n  let p = 2.0 * l - q;\n  \n  return vec3(\n    hue2rgb(p, q, h + 1.0 / 3.0),\n    hue2rgb(p, q, h),\n    hue2rgb(p, q, h - 1.0 / 3.0)\n  );\n}"
        }
      ]
    },
    {
      "name": "Animation & Easing",
      "slug": "animation---easing",
      "description": "",
      "functions": [
        {
          "name": "bezierCubic",
          "description": "a cubic Bezier curve and returns both value and derivative.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Parameter along the curve (0-1)."
            },
            {
              "name": "p0",
              "type": "f32",
              "description": "First control point."
            },
            {
              "name": "p1",
              "type": "f32",
              "description": "Second control point."
            },
            {
              "name": "p2",
              "type": "f32",
              "description": "Third control point."
            },
            {
              "name": "p3",
              "type": "f32",
              "description": "Fourth control point."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative (tangent)."
          },
          "wgslCode": "fn bezierCubic(t: f32, p0: f32, p1: f32, p2: f32, p3: f32) -> vec2<f32> {\n  // Clamp t to [0,1]\n  let tt = clamp(t, 0.0, 1.0);\n  \n  // Calculate curve value using cubic Bezier formula\n  // P(t) = (1-t)P + 3(1-t)tP + 3(1-t)tP + tP\n  let t1 = 1.0 - tt;\n  let t1Squared = t1 * t1;\n  let t1Cubed = t1Squared * t1;\n  let tSquared = tt * tt;\n  let tCubed = tSquared * tt;\n  \n  let value = t1Cubed * p0 + \n             3.0 * t1Squared * tt * p1 + \n             3.0 * t1 * tSquared * p2 + \n             tCubed * p3;\n  \n  // Calculate derivative for tangent information\n  // P'(t) = 3(1-t)(P-P) + 6(1-t)t(P-P) + 3t(P-P)\n  let derivative = 3.0 * t1Squared * (p1 - p0) +\n                  6.0 * t1 * tt * (p2 - p1) +\n                  3.0 * tSquared * (p3 - p2);\n  \n  return vec2<f32>(value, derivative);\n}"
        },
        {
          "name": "easeIn",
          "description": "ease-in function for smooth acceleration.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            },
            {
              "name": "power",
              "type": "f32",
              "description": "Easing power (higher = more pronounced curve)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value."
          },
          "wgslCode": "fn easeIn(t: f32, power: f32) -> f32 {\n  return pow(clamp(t, 0.0, 1.0), power);\n}"
        },
        {
          "name": "easeOut",
          "description": "ease-out function for smooth deceleration.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            },
            {
              "name": "power",
              "type": "f32",
              "description": "Easing power (higher = more pronounced curve)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value."
          },
          "wgslCode": "fn easeOut(t: f32, power: f32) -> f32 {\n  return 1.0 - pow(1.0 - clamp(t, 0.0, 1.0), power);\n}"
        },
        {
          "name": "easeInOut",
          "description": "ease-in-out function for smooth acceleration and deceleration.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            },
            {
              "name": "power",
              "type": "f32",
              "description": "Easing power (higher = more pronounced curve)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value."
          },
          "wgslCode": "fn easeInOut(t: f32, power: f32) -> f32 {\n  let tt = clamp(t, 0.0, 1.0);\n  if (tt < 0.5) {\n    return 0.5 * pow(2.0 * tt, power);\n  } else {\n    return 0.5 + 0.5 * (1.0 - pow(2.0 * (1.0 - tt), power));\n  }\n}"
        },
        {
          "name": "elasticIn",
          "description": "ease-in function with oscillating motion.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value with elastic effect."
          },
          "wgslCode": "fn elasticIn(t: f32) -> f32 {\n  let tt = clamp(t, 0.0, 1.0);\n  return sin(13.0 * 3.14159 * tt) * pow(2.0, 10.0 * (tt - 1.0));\n}"
        },
        {
          "name": "elasticOut",
          "description": "ease-out function with oscillating motion.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value with elastic effect."
          },
          "wgslCode": "fn elasticOut(t: f32) -> f32 {\n  let tt = clamp(t, 0.0, 1.0);\n  return sin(-13.0 * 3.14159 * (tt + 1.0)) * pow(2.0, -10.0 * tt) + 1.0;\n}"
        },
        {
          "name": "backIn",
          "description": "ease-in function that overshoots before settling.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value with back effect."
          },
          "wgslCode": "fn backIn(t: f32) -> f32 {\n  let s = 1.70158;\n  let tt = clamp(t, 0.0, 1.0);\n  return tt * tt * ((s + 1.0) * tt - s);\n}"
        },
        {
          "name": "backOut",
          "description": "ease-out function that overshoots before settling.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (0-1)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value with back effect."
          },
          "wgslCode": "fn backOut(t: f32) -> f32 {\n  let s = 1.70158;\n  let tt = clamp(t, 0.0, 1.0);\n  let tMinus = tt - 1.0;\n  return tMinus * tMinus * ((s + 1.0) * tMinus + s) + 1.0;\n}"
        },
        {
          "name": "springPhysics",
          "description": "spring animation with configurable parameters.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Time parameter."
            },
            {
              "name": "targetPosition",
              "type": "f32",
              "description": "Target position for the spring."
            },
            {
              "name": "initialPos",
              "type": "f32",
              "description": "Initial position."
            },
            {
              "name": "initialVel",
              "type": "f32",
              "description": "Initial velocity."
            },
            {
              "name": "stiffness",
              "type": "f32",
              "description": "Spring stiffness coefficient."
            },
            {
              "name": "damping",
              "type": "f32",
              "description": "Damping coefficient."
            },
            {
              "name": "mass",
              "type": "f32",
              "description": "Mass of the spring system."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "and velocity at time t."
          },
          "wgslCode": "fn springPhysics(t: f32, targetPosition: f32, initialPos: f32, initialVel: f32, stiffness: f32, damping: f32, mass: f32) -> vec2<f32> {\n  // Ensure positive values for stiffness, damping, and mass\n  let k = max(0.0001, stiffness);\n  let d = max(0.0, damping);\n  let m = max(0.0001, mass);\n  \n  // Calculate the angular frequency and damping ratio\n  let omega = sqrt(k / m);\n  let zeta = d / (2.0 * sqrt(k * m));\n  \n  // Initial displacement from targetPosition position\n  let x0 = initialPos - targetPosition;\n  let v0 = initialVel;\n  \n  var position: f32 = 0.0;\n  var velocity: f32 = 0.0;\n  \n  if (zeta < 1.0) {\n    // Underdamped case\n    let omega_d = omega * sqrt(1.0 - zeta * zeta);\n    let A = x0;\n    let B = (v0 + zeta * omega * x0) / omega_d;\n    \n    // Calculate exponential decay term\n    let expTerm = exp(-zeta * omega * t);\n    \n    // Calculate position and velocity\n    position = targetPosition + expTerm * (A * cos(omega_d * t) + B * sin(omega_d * t));\n    velocity = expTerm * (\n                -zeta * omega * A * cos(omega_d * t) - omega_d * A * sin(omega_d * t) +\n                -zeta * omega * B * sin(omega_d * t) + omega_d * B * cos(omega_d * t)\n               );\n  } else if (zeta == 1.0) {\n    // Critically damped case\n    let A = x0;\n    let B = v0 + omega * x0;\n    \n    // Calculate exponential decay term\n    let expTerm = exp(-omega * t);\n    \n    // Calculate position and velocity\n    position = targetPosition + expTerm * (A + B * t);\n    velocity = expTerm * (B - omega * (A + B * t));\n  } else {\n    // Overdamped case\n    let omega1 = -omega * (zeta + sqrt(zeta * zeta - 1.0));\n    let omega2 = -omega * (zeta - sqrt(zeta * zeta - 1.0));\n    \n    let A = (v0 - omega2 * x0) / (omega1 - omega2);\n    let B = x0 - A;\n    \n    // Calculate position and velocity\n    position = targetPosition + A * exp(omega1 * t) + B * exp(omega2 * t);\n    velocity = A * omega1 * exp(omega1 * t) + B * omega2 * exp(omega2 * t);\n  }\n  \n  return vec2<f32>(position, velocity);\n}"
        }
      ]
    },
    {
      "name": "Wave Functions",
      "slug": "wave-functions",
      "description": "",
      "functions": [
        {
          "name": "triangleWave",
          "description": "a triangle wave with configurable frequency and amplitude.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn triangleWave(x: f32, frequency: f32, amplitude: f32, phase: f32) -> f32 {\n  let t = x * frequency + phase;\n  let tt = fract(t);\n  let result = abs(2.0 * tt - 1.0);\n  return (1.0 - result) * amplitude;\n}"
        },
        {
          "name": "sawtoothWave",
          "description": "a sawtooth wave with linear ramp.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn sawtoothWave(x: f32, frequency: f32, amplitude: f32, phase: f32) -> f32 {\n  let t = x * frequency + phase;\n  let tt = fract(t);\n  return tt * amplitude;\n}"
        },
        {
          "name": "squareWave",
          "description": "a square wave with configurable duty cycle.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset."
            },
            {
              "name": "dutyCycle",
              "type": "f32",
              "description": "Duty cycle (0-1) for wave on/off ratio."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn squareWave(x: f32, frequency: f32, amplitude: f32, phase: f32, dutyCycle: f32) -> f32 {\n  let t = x * frequency + phase;\n  let tt = fract(t);\n  return select(0.0, amplitude, tt < dutyCycle);\n}"
        },
        {
          "name": "pulseWave",
          "description": "a pulse wave with smooth falloff edges.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset."
            },
            {
              "name": "width",
              "type": "f32",
              "description": "Pulse width (0-1)."
            },
            {
              "name": "falloff",
              "type": "f32",
              "description": "Smooth falloff duration."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn pulseWave(x: f32, frequency: f32, amplitude: f32, phase: f32, width: f32, falloff: f32) -> f32 {\n  let t = x * frequency + phase;\n  let tt = fract(t);\n  \n  // Create a pulse with smooth edges\n  var pulse = 0.0;\n  \n  // If tt is within the width, pulse is 1.0\n  if (tt < width) {\n    pulse = 1.0;\n  } else if (tt < width + falloff) {\n    // Smooth falloff\n    pulse = 1.0 - (tt - width) / falloff;\n  }\n  \n  return pulse * amplitude;\n}"
        },
        {
          "name": "chirpWave",
          "description": "a chirp wave with linearly changing frequency.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "startFrequency",
              "type": "f32",
              "description": "Starting frequency."
            },
            {
              "name": "endFrequency",
              "type": "f32",
              "description": "Ending frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "period",
              "type": "f32",
              "description": "Period over which frequency changes."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn chirpWave(x: f32, startFrequency: f32, endFrequency: f32, amplitude: f32, period: f32) -> f32 {\n  // Calculate the time within the current period\n  let t = fract(x / period);\n  \n  // Calculate the frequency at the current time (linear interpolation)\n  let freq = mix(startFrequency, endFrequency, t);\n  \n  // Calculate the phase which increases with changing frequency\n  let k = (endFrequency - startFrequency) / period;\n  let phase = 2.0 * 3.14159 * (startFrequency * t + 0.5 * k * t * t);\n  \n  // Return the sine wave with the calculated phase\n  return sin(phase) * amplitude;\n}"
        },
        {
          "name": "noiseWave",
          "description": "a wave using interpolated noise for organic variation.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude."
            },
            {
              "name": "seed",
              "type": "f32",
              "description": "Random seed for noise generation."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn noiseWave(x: f32, frequency: f32, amplitude: f32, seed: f32) -> f32 {\n  // Create interpolated noise\n  let t = x * frequency;\n  let floorT = floor(t);\n  let fractT = fract(t);\n  \n  // Get four noise values and interpolate between them\n  let n0 = hash1D(floorT + seed);\n  let n1 = hash1D(floorT + 1.0 + seed);\n  \n  // Smooth interpolation\n  let u = fractT * fractT * (3.0 - 2.0 * fractT); // Smoothstep\n  \n  return mix(n0, n1, u) * amplitude;\n}"
        }
      ]
    },
    {
      "name": "SDF Operations",
      "slug": "sdf-operations",
      "description": "",
      "functions": [
        {
          "name": "sdfOpUnion",
          "description": "two SDFs using union operation (logical OR).",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "signed distance field."
          },
          "wgslCode": "fn sdfOpUnion(distanceA: f32, distanceB: f32) -> f32 {\n  return min(distanceA, distanceB);\n}"
        },
        {
          "name": "sdfOpSubtract",
          "description": "one SDF from another (A - B).",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field to subtract."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "signed distance field."
          },
          "wgslCode": "fn sdfOpSubtract(distanceA: f32, distanceB: f32) -> f32 {\n  return max(distanceA, -distanceB);\n}"
        },
        {
          "name": "sdfOpIntersect",
          "description": "two SDFs (logical AND).",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "signed distance field."
          },
          "wgslCode": "fn sdfOpIntersect(distanceA: f32, distanceB: f32) -> f32 {\n  return max(distanceA, distanceB);\n}"
        },
        {
          "name": "sdfSmoothUnion",
          "description": "two SDFs using smooth union operation with configurable smoothing.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for the blend."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "combined signed distance field."
          },
          "wgslCode": "fn sdfSmoothUnion(distanceA: f32, distanceB: f32, smoothing: f32) -> f32 {\n  let h = clamp(0.5 + 0.5 * (distanceB - distanceA) / smoothing, 0.0, 1.0);\n  return mix(distanceB, distanceA, h) - smoothing * h * (1.0 - h);\n}"
        },
        {
          "name": "sdfSmoothSubtract",
          "description": "one SDF from another with smooth blending.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field to subtract."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for the blend."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "subtracted signed distance field."
          },
          "wgslCode": "fn sdfSmoothSubtract(distanceA: f32, distanceB: f32, smoothing: f32) -> f32 {\n  let h = clamp(0.5 - 0.5 * (distanceB + distanceA) / smoothing, 0.0, 1.0);\n  return mix(distanceA, -distanceB, h) + smoothing * h * (1.0 - h);\n}"
        },
        {
          "name": "sdfSmoothIntersect",
          "description": "two SDFs with smooth blending.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for the blend."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "intersected signed distance field."
          },
          "wgslCode": "fn sdfSmoothIntersect(distanceA: f32, distanceB: f32, smoothing: f32) -> f32 {\n  let h = clamp(0.5 - 0.5 * (distanceB - distanceA) / smoothing, 0.0, 1.0);\n  return mix(distanceB, distanceA, h) + smoothing * h * (1.0 - h);\n}"
        },
        {
          "name": "sdfChamferUnion",
          "description": "two SDFs using chamfer union operation with hard edges.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Chamfer radius for the edge."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "union signed distance field."
          },
          "wgslCode": "fn sdfChamferUnion(distanceA: f32, distanceB: f32, radius: f32) -> f32 {\n  return min(min(distanceA, distanceB), (distanceA - radius + distanceB) * 0.5);\n}"
        },
        {
          "name": "sdfChamferSubtract",
          "description": "one SDF from another using chamfer operation.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field to subtract."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Chamfer radius for the edge."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "subtraction signed distance field."
          },
          "wgslCode": "fn sdfChamferSubtract(distanceA: f32, distanceB: f32, radius: f32) -> f32 {\n  return max(max(distanceA, -distanceB), (distanceA + radius - distanceB) * 0.5);\n}"
        },
        {
          "name": "sdfChamferIntersect",
          "description": "two SDFs using chamfer operation.",
          "params": [
            {
              "name": "distanceA",
              "type": "f32",
              "description": "First signed distance field."
            },
            {
              "name": "distanceB",
              "type": "f32",
              "description": "Second signed distance field."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Chamfer radius for the edge."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "intersection signed distance field."
          },
          "wgslCode": "fn sdfChamferIntersect(distanceA: f32, distanceB: f32, radius: f32) -> f32 {\n  return max(max(distanceA, distanceB), (distanceA + radius + distanceB) * 0.5);\n}"
        }
      ]
    },
    {
      "name": "SDF Transforms",
      "slug": "sdf-transforms",
      "description": "",
      "functions": [
        {
          "name": "sdfTranslate",
          "description": "an SDF by moving its position.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "offset",
              "type": "vec3<f32>",
              "description": "Translation offset."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "wgslCode": "fn sdfTranslate(position: vec3<f32>, offset: vec3<f32>) -> vec3<f32> {\n  return position - offset;\n}"
        },
        {
          "name": "sdfScale",
          "description": "an SDF uniformly or non-uniformly.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "scale",
              "type": "vec3<f32>",
              "description": "Scale factors for each axis."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "wgslCode": "fn sdfScale(position: vec3<f32>, scale: vec3<f32>) -> vec3<f32> {\n  return position / scale;\n}"
        },
        {
          "name": "sdfRotate",
          "description": "an SDF around a pivot point with Euler angles.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "angles",
              "type": "vec3<f32>",
              "description": "Rotation angles in radians (x, y, z)."
            },
            {
              "name": "pivot",
              "type": "vec3<f32>",
              "description": "Point to rotate around."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "wgslCode": "fn sdfRotate(position: vec3<f32>, angles: vec3<f32>, pivot: vec3<f32>) -> vec3<f32> {\n  // First translate to origin relative to pivot point\n  let centered = position - pivot;\n  \n  // Create rotation matrices (inverse rotation = negative angles)\n  let cx = cos(-angles.x);\n  let sx = sin(-angles.x);\n  let cy = cos(-angles.y);\n  let sy = sin(-angles.y);\n  let cz = cos(-angles.z);\n  let sz = sin(-angles.z);\n  \n  // Rotate around X axis\n  let rx = vec3<f32>(\n    centered.x,\n    centered.y * cx - centered.z * sx,\n    centered.y * sx + centered.z * cx\n  );\n  \n  // Rotate around Y axis\n  let ry = vec3<f32>(\n    rx.x * cy + rx.z * sy,\n    rx.y,\n    -rx.x * sy + rx.z * cy\n  );\n  \n  // Rotate around Z axis\n  let rz = vec3<f32>(\n    ry.x * cz - ry.y * sz,\n    ry.x * sz + ry.y * cz,\n    ry.z\n  );\n  \n  // Translate back from pivot point\n  return rz + pivot;\n}"
        },
        {
          "name": "sdfMirror",
          "description": "an SDF across a plane defined by a normal vector.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "normal",
              "type": "vec3<f32>",
              "description": "Normal vector of the mirror plane."
            },
            {
              "name": "offset",
              "type": "f32",
              "description": "Distance offset of the mirror plane."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "wgslCode": "fn sdfMirror(position: vec3<f32>, normal: vec3<f32>, offset: f32) -> vec3<f32> {\n  let n = normalize(normal);\n  let d = dot(position, n) - offset;\n  return position - 2.0 * max(0.0, d) * n;\n}"
        },
        {
          "name": "sdfPolarRepeat",
          "description": "polar repetition around an axis.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "count",
              "type": "f32",
              "description": "Number of repetitions around the circle."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Axis to repeat around (should be normalized)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "wgslCode": "fn sdfPolarRepeat(position: vec3<f32>, count: f32, axis: vec3<f32>) -> vec3<f32> {\n  let n = normalize(axis);\n  \n  // Project position onto axis\n  let axisProj = dot(position, n) * n;\n  let radial = position - axisProj;\n  \n  // Get angle in the plane perpendicular to axis\n  let radius = length(radial);\n  if (radius < 0.001) {\n    return position;\n  }\n  \n  let angle = atan2(radial.y, radial.x);\n  let sectorAngle = 6.28318530718 / count;\n  let snappedAngle = round(angle / sectorAngle) * sectorAngle;\n  \n  // Reconstruct position with snapped angle\n  let newRadial = radius * vec2<f32>(cos(snappedAngle), sin(snappedAngle));\n  \n  // This assumes axis is along Z - for general axis, need proper basis vectors\n  return axisProj + vec3<f32>(newRadial.x, newRadial.y, 0.0);\n}"
        },
        {
          "name": "sdfCylindricalRepeat",
          "description": "cylindrical coordinate repetition.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "angleRepeat",
              "type": "f32",
              "description": "Angular repetition count."
            },
            {
              "name": "heightRepeat",
              "type": "f32",
              "description": "Height repetition interval."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Cylindrical axis (should be normalized)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "wgslCode": "fn sdfCylindricalRepeat(position: vec3<f32>, angleRepeat: f32, heightRepeat: f32, axis: vec3<f32>) -> vec3<f32> {\n  let n = normalize(axis);\n  \n  // Project onto axis for height\n  let h = dot(position, n);\n  let radial = position - h * n;\n  \n  // Repeat in height\n  let newH = h - heightRepeat * round(h / heightRepeat);\n  \n  // Repeat in angle\n  let radius = length(radial);\n  if (radius < 0.001) {\n    return newH * n;\n  }\n  \n  let angle = atan2(radial.y, radial.x);\n  let sectorAngle = 6.28318530718 / angleRepeat;\n  let newAngle = angle - sectorAngle * round(angle / sectorAngle);\n  \n  let newRadial = radius * vec2<f32>(cos(newAngle), sin(newAngle));\n  \n  // This assumes axis is along Z - for general axis, need proper basis vectors\n  return newH * n + vec3<f32>(newRadial.x, newRadial.y, 0.0);\n}"
        },
        {
          "name": "sdfSphericalRepeat",
          "description": "spherical coordinate repetition.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "phiRepeat",
              "type": "f32",
              "description": "Azimuthal angle repetition count."
            },
            {
              "name": "thetaRepeat",
              "type": "f32",
              "description": "Polar angle repetition count."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "wgslCode": "fn sdfSphericalRepeat(position: vec3<f32>, phiRepeat: f32, thetaRepeat: f32) -> vec3<f32> {\n  let radius = length(position);\n  if (radius < 0.001) {\n    return position;\n  }\n  \n  // Convert to spherical coordinates\n  let theta = acos(clamp(position.z / radius, -1.0, 1.0));\n  let phi = atan2(position.y, position.x);\n  \n  // Repeat in spherical coordinates\n  let phiSector = 6.28318530718 / phiRepeat;\n  let thetaSector = 3.14159265359 / thetaRepeat;\n  \n  let newPhi = phi - phiSector * round(phi / phiSector);\n  let newTheta = theta - thetaSector * round(theta / thetaSector);\n  \n  // Convert back to Cartesian\n  let sinTheta = sin(newTheta);\n  return radius * vec3<f32>(\n    sinTheta * cos(newPhi),\n    sinTheta * sin(newPhi),\n    cos(newTheta)\n  );\n}"
        }
      ]
    },
    {
      "name": "SDF Modifiers",
      "slug": "sdf-modifiers",
      "description": "",
      "functions": [
        {
          "name": "sdfTwist",
          "description": "a continuous rotation around an axis proportional to distance along that axis.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Twist angle in radians per unit distance."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Axis to twist around (should be normalized)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "wgslCode": "fn sdfTwist(position: vec3<f32>, angle: f32, axis: vec3<f32>) -> vec3<f32> {\n  // Normalize the axis\n  let axisNorm = normalize(axis);\n  \n  // Project position onto the twist axis\n  let proj = dot(position, axisNorm);\n  \n  // Calculate twist angle based on projection along axis\n  let twistAngle = proj * angle;\n  \n  // Get sin and cos of the twist angle\n  let s = sin(twistAngle);\n  let c = cos(twistAngle);\n  \n  // Calculate vector from axis (the part that will be rotated)\n  let axisProj = proj * axisNorm;\n  let fromAxis = position - axisProj;\n  \n  // Find a perpendicular vector for the rotation\n  let basis1 = normalize(fromAxis);\n  let basis2 = cross(axisNorm, basis1);\n  \n  // Rotate using the basis vectors\n  let rotated = axisProj + \n                basis1 * length(fromAxis) * c + \n                basis2 * length(fromAxis) * s;\n  \n  return rotated;\n}"
        },
        {
          "name": "sdfBend",
          "description": "geometry along a specified axis creating a smooth curve.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Bend angle in radians."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Axis normal to the bending plane."
            },
            {
              "name": "center",
              "type": "vec3<f32>",
              "description": "Center of the bend."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "wgslCode": "fn sdfBend(position: vec3<f32>, angle: f32, axis: vec3<f32>, center: vec3<f32>) -> vec3<f32> {\n  // Normalize the bend axis\n  let axisNorm = normalize(axis);\n  \n  // Translate position relative to bend center\n  let localPos = position - center;\n  \n  // Find perpendicular vectors to the bend axis to define the bend plane\n  var perpVec1: vec3<f32>;\n  if (abs(axisNorm.y) < 0.999) {\n    perpVec1 = normalize(cross(vec3<f32>(0.0, 1.0, 0.0), axisNorm));\n  } else {\n    perpVec1 = normalize(cross(vec3<f32>(1.0, 0.0, 0.0), axisNorm));\n  }\n  let perpVec2 = normalize(cross(axisNorm, perpVec1));\n  \n  // Project the position onto the perpendicular vectors\n  let proj1 = dot(localPos, perpVec1);\n  let proj2 = dot(localPos, perpVec2);\n  let axisProj = dot(localPos, axisNorm);\n  \n  // Calculate radius for the bend\n  let radius = proj1;\n  \n  // Calculate the angle based on the distance along the bend direction\n  let bendAngle = proj2 * angle;\n  \n  // Calculate the bent position using polar coordinates\n  let c = cos(bendAngle);\n  let s = sin(bendAngle);\n  \n  // Apply the transformation\n  let bentPos = center + \n                axisNorm * axisProj +\n                perpVec1 * (c * radius) +\n                perpVec2 * (s * radius);\n  \n  return bentPos;\n}"
        },
        {
          "name": "sdfTaper",
          "description": "a linear taper effect along an axis.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "amount",
              "type": "f32",
              "description": "Taper amount (0 = no taper, 1 = full taper)."
            },
            {
              "name": "axis",
              "type": "vec3<f32>",
              "description": "Taper axis direction."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height over which to apply the taper."
            },
            {
              "name": "offset",
              "type": "f32",
              "description": "Offset along the taper axis."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "wgslCode": "fn sdfTaper(position: vec3<f32>, amount: f32, axis: vec3<f32>, height: f32, offset: f32) -> vec3<f32> {\n  let axisNorm = normalize(axis);\n  \n  // Project position onto the taper axis\n  let axisPos = dot(position, axisNorm) - offset;\n  \n  // Calculate taper factor based on position along axis\n  let t = clamp(axisPos / height, 0.0, 1.0);\n  let taperFactor = 1.0 - amount * t;\n  \n  // Apply taper to the perpendicular components\n  let axisComponent = axisPos * axisNorm;\n  let perpComponent = position - dot(position, axisNorm) * axisNorm;\n  \n  return axisComponent + perpComponent * taperFactor;\n}"
        },
        {
          "name": "sdfDisplace",
          "description": "SDF using noise or other displacement functions.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to displace."
            },
            {
              "name": "amount",
              "type": "f32",
              "description": "Displacement amount."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Displacement frequency."
            },
            {
              "name": "seed",
              "type": "f32",
              "description": "Random seed for displacement."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "position."
          },
          "wgslCode": "fn sdfDisplace(position: vec3<f32>, amount: f32, frequency: f32, seed: f32) -> vec3<f32> {\n  let noisePos = position * frequency + seed;\n  let displacement = hash3D(noisePos) * amount;\n  \n  return position + displacement;\n}"
        },
        {
          "name": "sdfDomainRepeat",
          "description": "domain repetition with optional warping for complex patterns.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "cellSize",
              "type": "vec3<f32>",
              "description": "Size of each repetition cell."
            },
            {
              "name": "warpAmount",
              "type": "f32",
              "description": "Amount of warping to apply."
            },
            {
              "name": "warpScale",
              "type": "f32",
              "description": "Scale of the warping effect."
            },
            {
              "name": "seed",
              "type": "f32",
              "description": "Random seed for warping."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "wgslCode": "fn sdfDomainRepeat(position: vec3<f32>, cellSize: vec3<f32>, warpAmount: f32, warpScale: f32, seed: f32) -> vec3<f32> {\n  // Calculate warping for position\n  let warp = warpNoise3D(position * warpScale, seed) * warpAmount;\n  \n  // Apply warping to position\n  let warpedPos = position + warp;\n  \n  // Calculate repetition\n  return warpedPos - cellSize * round(warpedPos / cellSize);\n}"
        },
        {
          "name": "sdfFiniteRepeat",
          "description": "finite repetition with specified count along each axis.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "spacing",
              "type": "vec3<f32>",
              "description": "Spacing between repetitions."
            },
            {
              "name": "count",
              "type": "vec3<f32>",
              "description": "Number of repetitions along each axis."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "wgslCode": "fn sdfFiniteRepeat(position: vec3<f32>, spacing: vec3<f32>, count: vec3<f32>) -> vec3<f32> {\n  let id = clamp(round(position / spacing), -count * 0.5, count * 0.5);\n  return position - spacing * id;\n}"
        },
        {
          "name": "sdfInfiniteRepeat",
          "description": "infinite repetition along all axes.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to transform."
            },
            {
              "name": "spacing",
              "type": "vec3<f32>",
              "description": "Spacing between repetitions."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "repeated position."
          },
          "wgslCode": "fn sdfInfiniteRepeat(position: vec3<f32>, spacing: vec3<f32>) -> vec3<f32> {\n  return position - spacing * round(position / spacing);\n}"
        }
      ]
    },
    {
      "name": "SDF Utilities",
      "slug": "sdf-utilities",
      "description": "",
      "functions": [
        {
          "name": "sdfToSolid",
          "description": "a signed distance field to a solid boolean value.",
          "params": [
            {
              "name": "signedDistance",
              "type": "f32",
              "description": "Signed distance field value."
            },
            {
              "name": "threshold",
              "type": "f32",
              "description": "Threshold for solid determination."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "if solid, 0.0 if not (as f32 for compatibility)."
          },
          "wgslCode": "fn sdfToSolid(signedDistance: f32, threshold: f32) -> f32 {\n  return select(0.0, 1.0, signedDistance <= threshold);\n}"
        },
        {
          "name": "sdfToStroke",
          "description": "a signed distance field to a stroke/outline.",
          "params": [
            {
              "name": "signedDistance",
              "type": "f32",
              "description": "Signed distance field value."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Stroke thickness."
            },
            {
              "name": "center",
              "type": "f32",
              "description": "Center distance for the stroke."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "if within stroke, 0.0 if not."
          },
          "wgslCode": "fn sdfToStroke(signedDistance: f32, thickness: f32, center: f32) -> f32 {\n  return select(0.0, 1.0, abs(signedDistance - center) <= thickness * 0.5);\n}"
        },
        {
          "name": "sdfToSmoothSolid",
          "description": "a signed distance field to a smooth solid with anti-aliasing.",
          "params": [
            {
              "name": "signedDistance",
              "type": "f32",
              "description": "Signed distance field value."
            },
            {
              "name": "threshold",
              "type": "f32",
              "description": "Threshold for solid determination."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for anti-aliasing."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0.0 and 1.0."
          },
          "wgslCode": "fn sdfToSmoothSolid(signedDistance: f32, threshold: f32, smoothing: f32) -> f32 {\n  return 1.0 - smoothstep(threshold - smoothing, threshold + smoothing, signedDistance);\n}"
        },
        {
          "name": "sdfToSmoothStroke",
          "description": "a signed distance field to a smooth stroke with anti-aliasing.",
          "params": [
            {
              "name": "signedDistance",
              "type": "f32",
              "description": "Signed distance field value."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Stroke thickness."
            },
            {
              "name": "center",
              "type": "f32",
              "description": "Center distance for the stroke."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor for anti-aliasing."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "stroke value between 0.0 and 1.0."
          },
          "wgslCode": "fn sdfToSmoothStroke(signedDistance: f32, thickness: f32, center: f32, smoothing: f32) -> f32 {\n  let distance = abs(signedDistance - center);\n  return 1.0 - smoothstep(thickness * 0.5 - smoothing, thickness * 0.5 + smoothing, distance);\n}"
        }
      ]
    }
  ]
}