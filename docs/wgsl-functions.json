{
  "meta": {
    "generatedAt": "2025-07-17T11:24:14.855Z",
    "totalFunctions": 41,
    "totalCategories": 4
  },
  "categories": [
    {
      "name": "Math & Utility",
      "slug": "math---utility",
      "description": "Mathematical functions and general utilities for shader calculations.",
      "functions": [
        {
          "name": "elasticWave",
          "description": "an elastic wave with exponential decay and sinusoidal oscillation.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input position along the wave."
            },
            {
              "name": "amplitude",
              "type": "f32",
              "description": "Wave amplitude multiplier."
            },
            {
              "name": "frequency",
              "type": "f32",
              "description": "Wave frequency."
            },
            {
              "name": "decay",
              "type": "f32",
              "description": "Exponential decay factor."
            },
            {
              "name": "phase",
              "type": "f32",
              "description": "Phase offset for the wave."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "wave value."
          },
          "wgslCode": "fn elasticWave(x: f32, amplitude: f32, frequency: f32, decay: f32, phase: f32) -> f32 {\n  let d = max(0.001, decay);\n  let decayTerm = exp(-d * x);\n  let oscTerm = sin(frequency * x * 6.28318 + phase);\n  return amplitude * decayTerm * oscTerm;\n}"
        },
        {
          "name": "smoothStep",
          "description": "interpolation between two values with smooth acceleration and deceleration.",
          "params": [
            {
              "name": "edge0",
              "type": "f32",
              "description": "Lower edge of interpolation range."
            },
            {
              "name": "edge1",
              "type": "f32",
              "description": "Upper edge of interpolation range."
            },
            {
              "name": "x",
              "type": "f32",
              "description": "Input value to interpolate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "interpolated value between 0 and 1."
          },
          "wgslCode": "fn smoothStep(edge0: f32, edge1: f32, x: f32) -> f32 {\n  let t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  return t * t * (3.0 - 2.0 * t);\n}"
        },
        {
          "name": "rotate2D",
          "description": "a 2D vector by a given angle.",
          "params": [
            {
              "name": "v",
              "type": "vec2<f32>",
              "description": "Input 2D vector to rotate."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Rotation angle in radians."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "2D vector."
          },
          "wgslCode": "fn rotate2D(v: vec2<f32>, angle: f32) -> vec2<f32> {\n  let c = cos(angle);\n  let s = sin(angle);\n  return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}"
        },
        {
          "name": "exponentialRamp",
          "description": "an exponential ramp function with derivative.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "base",
              "type": "f32",
              "description": "Exponential base."
            },
            {
              "name": "scale",
              "type": "f32",
              "description": "Scale factor."
            },
            {
              "name": "offset",
              "type": "f32",
              "description": "Vertical offset."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative."
          },
          "wgslCode": "fn exponentialRamp(x: f32, base: f32, scale: f32, offset: f32) -> vec2<f32> {\n  // Ensure base is positive and not 1 (which would make it linear)\n  let b = select(base, 2.71828, abs(base - 1.0) < 0.001);\n  \n  // Calculate the exponential function\n  let result = scale * pow(b, x) + offset;\n  \n  // Calculate the derivative\n  let derivative = scale * pow(b, x) * log(b);\n  \n  return vec2<f32>(result, derivative);\n}"
        },
        {
          "name": "logisticCurve",
          "description": "a logistic (S-curve) function with derivative.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "midpoint",
              "type": "f32",
              "description": "Curve midpoint (inflection point)."
            },
            {
              "name": "steepness",
              "type": "f32",
              "description": "Curve steepness factor."
            },
            {
              "name": "min",
              "type": "f32",
              "description": "Minimum output value."
            },
            {
              "name": "max",
              "type": "f32",
              "description": "Maximum output value."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and derivative."
          },
          "wgslCode": "fn logisticCurve(x: f32, midpoint: f32, steepness: f32, min: f32, max: f32) -> vec2<f32> {\n  // Scale factor for steepness\n  let k = max(0.001, steepness);\n  \n  // Shift x relative to midpoint\n  let z = -k * (x - midpoint);\n  \n  // Calculate the exponent\n  let expTerm = exp(z);\n  \n  // Calculate the logistic function value\n  let logistic = 1.0 / (1.0 + expTerm);\n  \n  // Scale to min-max range\n  let range = max - min;\n  let value = min + range * logistic;\n  \n  // Calculate the derivative\n  let derivative = range * k * expTerm / ((1.0 + expTerm) * (1.0 + expTerm));\n  \n  return vec2<f32>(value, derivative);\n}"
        },
        {
          "name": "stepSequence",
          "description": "a stepped sequence with optional smoothing between steps.",
          "params": [
            {
              "name": "x",
              "type": "f32",
              "description": "Input value."
            },
            {
              "name": "steps",
              "type": "f32",
              "description": "Number of steps in the sequence."
            },
            {
              "name": "smoothing",
              "type": "f32",
              "description": "Smoothing factor between steps (0-1)."
            },
            {
              "name": "minValue",
              "type": "f32",
              "description": "Minimum output value."
            },
            {
              "name": "maxValue",
              "type": "f32",
              "description": "Maximum output value."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "value and current step index."
          },
          "wgslCode": "fn stepSequence(x: f32, steps: f32, smoothing: f32, minValue: f32, maxValue: f32) -> vec2<f32> {\n  // Ensure at least 1 step and positive smoothing\n  let numSteps = max(1.0, floor(steps));\n  let smoothFactor = max(0.0, smoothing);\n  \n  // Normalize x to 0-1 range\n  let normalizedX = fract(x);\n  \n  // Calculate the size of each step\n  let stepSize = 1.0 / numSteps;\n  \n  // Calculate the current step (0 to numSteps-1)\n  let currentStep = floor(normalizedX * numSteps);\n  let nextStep = fract(currentStep + 1.0);\n  \n  // Calculate progress within the current step\n  let stepProgress = fract(normalizedX * numSteps);\n  \n  // Calculate the progress values for current and next steps\n  let currentStepValue = currentStep / (numSteps - 1.0);\n  \n  // Prepare next step value, handle the last step case\n  var nextStepValue: f32 = 0.0;\n  if (currentStep >= numSteps - 1.0) {\n    nextStepValue = 1.0;\n  } else {\n    nextStepValue = nextStep / (numSteps - 1.0);\n  }\n  \n  // Apply smoothing between steps if needed\n  var result: f32 = 0.0;\n  \n  if (smoothFactor > 0.0 && stepProgress > (1.0 - smoothFactor) && numSteps > 1.0) {\n    // Calculate smoothing factor\n    let t = (stepProgress - (1.0 - smoothFactor)) / smoothFactor;\n    \n    // Smoothstep for better transition\n    let smoothT = t * t * (3.0 - 2.0 * t);\n    \n    // Interpolate between current and next step\n    result = mix(currentStepValue, nextStepValue, smoothT);\n  } else {\n    result = currentStepValue;\n  }\n  \n  // Scale to min-max range\n  let range = maxValue - minValue;\n  let finalResult = minValue + result * range;\n  \n  return vec2<f32>(finalResult, currentStep);\n}"
        }
      ]
    },
    {
      "name": "Noise & Procedural",
      "slug": "noise---procedural",
      "description": "Noise generation and procedural pattern functions for textures and effects.",
      "functions": [
        {
          "name": "hash22",
          "description": "a 2D hash from a 2D input vector for procedural generation.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D vector to hash."
            }
          ],
          "returns": {
            "type": "vec2<f32>",
            "description": "result as 2D vector."
          },
          "wgslCode": "fn hash22(p: vec2<f32>) -> vec2<f32> {\n  var p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}"
        },
        {
          "name": "noise2D",
          "description": "2D Perlin-style noise for procedural textures and patterns.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value typically in range [-1, 1]."
          },
          "wgslCode": "fn noise2D(p: vec2<f32>) -> f32 {\n  let i = floor(p);\n  let f = fract(p);\n  let u = f * f * (3.0 - 2.0 * f);\n  return mix(\n    mix(dot(hash22(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n        dot(hash22(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n    mix(dot(hash22(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n        dot(hash22(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}"
        },
        {
          "name": "fbm",
          "description": "Brownian Motion - combines multiple octaves of noise for complex patterns.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Input 2D coordinate."
            },
            {
              "name": "octaves",
              "type": "i32",
              "description": "Number of noise octaves to combine."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "noise value."
          },
          "wgslCode": "fn fbm(p: vec2<f32>, octaves: i32) -> f32 {\n  var value = 0.0;\n  var amplitude = 0.5;\n  var frequency = 1.0;\n  for (var i = 0; i < octaves; i++) {\n    value += amplitude * noise2D(p * frequency);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n  }\n  return value;\n}"
        },
        {
          "name": "hash1D",
          "description": "a 1D hash value from an input value for noise generation.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "Input value to hash."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "value between 0 and 1."
          },
          "wgslCode": "fn hash1D(p: f32) -> f32 {\n  // Convert to integer and apply bit manipulation\n  let x = bitcast<u32>(p + 123.456789);\n  var h = x;\n  \n  // Wang hash function\n  h = (h ^ 61u) ^ (h >> 16u);\n  h = h + (h << 3u);\n  h = h ^ (h >> 4u);\n  h = h * 0x27d4eb2du;\n  h = h ^ (h >> 15u);\n  \n  // Convert back to float and normalize\n  return f32(h) / 4294967296.0;\n}"
        }
      ]
    },
    {
      "name": "Signed Distance Fields",
      "slug": "signed-distance-fields",
      "description": "SDF functions for procedural geometry and ray marching techniques.",
      "functions": [
        {
          "name": "sdfCircle",
          "description": "distance function for a circle.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Point to evaluate distance from."
            },
            {
              "name": "r",
              "type": "f32",
              "description": "Circle radius."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to circle surface (negative inside, positive outside)."
          },
          "wgslCode": "fn sdfCircle(p: vec2<f32>, r: f32) -> f32 {\n  return length(p) - r;\n}"
        },
        {
          "name": "sdfBox",
          "description": "distance function for a rectangular box.",
          "params": [
            {
              "name": "p",
              "type": "vec2<f32>",
              "description": "Point to evaluate distance from."
            },
            {
              "name": "b",
              "type": "vec2<f32>",
              "description": "Box half-dimensions (width/2, height/2)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to box surface (negative inside, positive outside)."
          },
          "wgslCode": "fn sdfBox(p: vec2<f32>, b: vec2<f32>) -> f32 {\n  let d = abs(p) - b;\n  return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);\n}"
        },
        {
          "name": "sdfUnion",
          "description": "two SDFs using union operation (closest surface).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from first shape."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from second shape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing union of both shapes."
          },
          "wgslCode": "fn sdfUnion(d1: f32, d2: f32) -> f32 {\n  return min(d1, d2);\n}"
        },
        {
          "name": "sdfIntersection",
          "description": "two SDFs using intersection operation (overlapping area only).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from first shape."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from second shape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing intersection of both shapes."
          },
          "wgslCode": "fn sdfIntersection(d1: f32, d2: f32) -> f32 {\n  return max(d1, d2);\n}"
        },
        {
          "name": "sdfSubtraction",
          "description": "two SDFs using subtraction operation (first shape minus second).",
          "params": [
            {
              "name": "d1",
              "type": "f32",
              "description": "Distance from shape to subtract from."
            },
            {
              "name": "d2",
              "type": "f32",
              "description": "Distance from shape to subtract."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance representing first shape with second subtracted."
          },
          "wgslCode": "fn sdfSubtraction(d1: f32, d2: f32) -> f32 {\n  return max(-d1, d2);\n}"
        },
        {
          "name": "boxFrameSDF",
          "description": "a signed distance field for a 3D box frame (hollow box).",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "vec3<f32>",
              "description": "Half-extents of the box."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Wall thickness of the frame."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the box frame surface."
          },
          "wgslCode": "fn boxFrameSDF(position: vec3<f32>, size: vec3<f32>, thickness: f32) -> f32 {\n  let q = abs(position) - size;\n  let w = abs(q + thickness) - thickness;\n  return min(min(\n    length(max(vec3<f32>(q.x, w.y, w.z), vec3<f32>(0.0))) + min(max(q.x, max(w.y, w.z)), 0.0),\n    length(max(vec3<f32>(w.x, q.y, w.z), vec3<f32>(0.0))) + min(max(w.x, max(q.y, w.z)), 0.0)),\n    length(max(vec3<f32>(w.x, w.y, q.z), vec3<f32>(0.0))) + min(max(w.x, max(w.y, q.z)), 0.0));\n}"
        },
        {
          "name": "cappedTorusSDF",
          "description": "a signed distance field for a capped torus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "majorRadius",
              "type": "f32",
              "description": "Major radius of the torus."
            },
            {
              "name": "minorRadius",
              "type": "f32",
              "description": "Minor radius of the torus."
            },
            {
              "name": "angle",
              "type": "f32",
              "description": "Cap angle in radians."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the capped torus surface."
          },
          "wgslCode": "fn cappedTorusSDF(position: vec3<f32>, majorRadius: f32, minorRadius: f32, angle: f32) -> f32 {\n  let sc = vec2<f32>(sin(angle), cos(angle));\n  let q = vec3<f32>(abs(position.x), position.y, position.z);\n  let k = select(\n    length(q.xy), \n    dot(q.xy, sc),\n    sc.y * q.x > sc.x * q.y\n  );\n  return sqrt(dot(q, q) + \n              majorRadius * majorRadius - \n              2.0 * majorRadius * k) - \n              minorRadius;\n}"
        },
        {
          "name": "capsuleSDF",
          "description": "a signed distance field for a capsule (cylinder with rounded caps).",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the capsule."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylindrical portion."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the capsule surface."
          },
          "wgslCode": "fn capsuleSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let d = abs(length(position.xz)) - radius;\n  let p = vec2<f32>(d, abs(position.y) - height * 0.5);\n  return length(max(p, vec2<f32>(0.0))) + min(max(p.x, p.y), 0.0) - radius;\n}"
        },
        {
          "name": "coneSDF",
          "description": "a signed distance field for a cone.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Base radius of the cone."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cone."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the cone surface."
          },
          "wgslCode": "fn coneSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let q = vec2<f32>(length(position.xz), position.y);\n  let h = height;\n  let r = radius;\n  \n  // Calculate distance\n  let d1 = -q.y - h;\n  let d2 = max(q.x * h - q.y * r, q.y * h + q.x * r);\n  \n  return length(max(vec2<f32>(d1, d2), vec2<f32>(0.0))) + min(max(d1, d2), 0.0);\n}"
        },
        {
          "name": "cylinderSDF",
          "description": "a signed distance field for a cylinder.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the cylinder."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylinder."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the cylinder surface."
          },
          "wgslCode": "fn cylinderSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  let d = vec2<f32>(length(position.xz), abs(position.y)) - vec2<f32>(radius, height * 0.5);\n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0)));\n}"
        },
        {
          "name": "ellipsoidSDF",
          "description": "a signed distance field for an ellipsoid.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "vec3<f32>",
              "description": "Radii along each axis."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the ellipsoid surface."
          },
          "wgslCode": "fn ellipsoidSDF(position: vec3<f32>, radius: vec3<f32>) -> f32 {\n  let k0 = length(position / radius);\n  let k1 = length(position / (radius * radius));\n  return k0 * (k0 - 1.0) / k1;\n}"
        },
        {
          "name": "gyroidSDF",
          "description": "a signed distance field for a gyroid surface.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "scale",
              "type": "f32",
              "description": "Scale factor for the gyroid pattern."
            },
            {
              "name": "thickness",
              "type": "f32",
              "description": "Thickness of the gyroid surface."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the gyroid surface."
          },
          "wgslCode": "fn gyroidSDF(position: vec3<f32>, scale: f32, thickness: f32) -> f32 {\n  let p = position * scale;\n  return (abs(dot(sin(p), cos(p.zxy))) - thickness) / scale;\n}"
        },
        {
          "name": "hexagonalPrismSDF",
          "description": "a signed distance field for a hexagonal prism.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the hexagon."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the prism."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the hexagonal prism surface."
          },
          "wgslCode": "fn hexagonalPrismSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  // Project into 2D\n  var p = abs(position);\n  let k = vec3<f32>(-0.866025404, 0.5, 0.577350269);\n  \n  // Hexagon in xy-plane\n  p = vec3<f32>(p.x + p.y * k.x, p.y * k.y, p.z);\n  p = vec3<f32>(p.x - min(p.x, p.y), p.y, p.z);\n  let d = vec2<f32>(length(vec2<f32>(p.x, p.y - radius * k.z)) - radius, abs(p.z) - height * 0.5);\n  \n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0)));\n}"
        },
        {
          "name": "icosahedronSDF",
          "description": "a signed distance field for an icosahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the icosahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the icosahedron surface."
          },
          "wgslCode": "fn icosahedronSDF(position: vec3<f32>, size: f32) -> f32 {\n  var p = position;\n  let s = size;\n  \n  // Constants for icosahedron\n  let phi = 1.618033988749895;\n  let a = s;\n  let b = s * phi;\n  \n  // Compute distance to icosahedron\n  p = abs(p / s);\n  let d = p.x * p.y * p.z;\n  let m = max(max(p.x, p.y), p.z);\n  let n = min(min(p.x, p.y), p.z);\n  let mid = p.x + p.y + p.z - m - n;\n  \n  // Calculate the signed distance\n  let q = select(mid, d, m < phi * n);\n  return (length(p) - phi) * s;\n}"
        },
        {
          "name": "juliaSDF",
          "description": "a signed distance field for a 4D Julia set fractal.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "c",
              "type": "vec4<f32>",
              "description": "Julia set parameter (quaternion)."
            },
            {
              "name": "iterations",
              "type": "f32",
              "description": "Maximum number of iterations."
            },
            {
              "name": "bailout",
              "type": "f32",
              "description": "Bailout radius for iteration escape."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the Julia set surface."
          },
          "wgslCode": "fn juliaSDF(position: vec3<f32>, c: vec4<f32>, iterations: f32, bailout: f32) -> f32 {\n  var z = vec4<f32>(position, 0.0);\n  var dz = vec4<f32>(1.0, 0.0, 0.0, 0.0);\n  var m = dot(z, z);\n  var i = 0;\n  \n  // Quaternion multiplication helper\n  let quatMul = fn(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\n    return vec4<f32>(\n      a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n      a.x * b.y + a.y * b.x + a.z * b.w - a.w * b.z,\n      a.x * b.z - a.y * b.w + a.z * b.x + a.w * b.y,\n      a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x\n    );\n  };\n  \n  // Julia set iteration\n  for (i = 0; i < i32(iterations) && m < bailout * bailout; i += 1) {\n    dz = 2.0 * quatMul(z, dz);\n    z = quatMul(z, z) + c;\n    m = dot(z, z);\n  }\n  \n  // Compute the distance\n  let dist = 0.5 * log(m) * sqrt(m) / length(dz);\n  return dist;\n}"
        },
        {
          "name": "octahedronSDF",
          "description": "a signed distance field for an octahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the octahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the octahedron surface."
          },
          "wgslCode": "fn octahedronSDF(position: vec3<f32>, size: f32) -> f32 {\n  let p = abs(position);\n  let m = p.x + p.y + p.z - size;\n  \n  // Calculate the distance\n  var q: vec3<f32>;\n  if (3.0 * p.x < m) {\n    q = p;\n  } else if (3.0 * p.y < m) {\n    q = vec3<f32>(p.x, p.z, p.y);\n  } else if (3.0 * p.z < m) {\n    q = vec3<f32>(p.x, p.y, p.z);\n  } else {\n    q = p;\n  }\n  \n  let k = clamp(0.5 * (q.z - q.y + size), 0.0, size);\n  return length(vec3<f32>(q.x, q.y - size + k, q.z - k));\n}"
        },
        {
          "name": "planeSDF",
          "description": "a signed distance field for an infinite plane.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "normal",
              "type": "vec3<f32>",
              "description": "Normal vector of the plane (should be normalized)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the plane surface."
          },
          "wgslCode": "fn planeSDF(position: vec3<f32>, normal: vec3<f32>) -> f32 {\n  let n = normalize(normal);\n  return dot(position, n);\n}"
        },
        {
          "name": "pyramidSDF",
          "description": "a signed distance field for a pyramid.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Base size of the pyramid."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the pyramid."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the pyramid surface."
          },
          "wgslCode": "fn pyramidSDF(position: vec3<f32>, size: f32, height: f32) -> f32 {\n  // Normalize position\n  var p = position;\n  let h = height;\n  let m2 = h * h + size * size;\n  \n  // Project into 2D\n  let q = abs(p);\n  p.y -= h;\n  p.y = max(p.y, 0.0);\n  \n  // Distance calculation\n  var d: f32;\n  if (max(q.x, q.z) < size) {\n    d = length(vec2<f32>(length(p.xz), p.y)) - sqrt(m2);\n  } else {\n    d = length(vec2<f32>(length(max(abs(p.xz) - vec2<f32>(size), vec2<f32>(0.0))), p.y));\n  }\n  \n  // Account for position below base\n  d = select(d, length(p) - sqrt(m2), p.y < 0.0);\n  \n  return d;\n}"
        },
        {
          "name": "rhombusSDF",
          "description": "a signed distance field for a rhombus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "dimensions",
              "type": "vec3<f32>",
              "description": "Dimensions of the rhombus."
            },
            {
              "name": "sharpness",
              "type": "f32",
              "description": "Sharpness factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rhombus surface."
          },
          "wgslCode": "fn rhombusSDF(position: vec3<f32>, dimensions: vec3<f32>, sharpness: f32) -> f32 {\n  var p = abs(position);\n  let b = dimensions;\n  let e = sharpness;\n  \n  // Calculate distance to rhombus\n  p = p - b;\n  let q = abs(p.x + p.y + p.z) + e;\n  let h = max(vec3<f32>(q) - vec3<f32>(e), vec3<f32>(0.0));\n  \n  return min(max(p.x, max(p.y, p.z)), 0.0) + length(h);\n}"
        },
        {
          "name": "roundBoxSDF",
          "description": "a signed distance field for a rounded box.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "vec3<f32>",
              "description": "Half-extents of the box."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Rounding radius for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded box surface."
          },
          "wgslCode": "fn roundBoxSDF(position: vec3<f32>, size: vec3<f32>, radius: f32) -> f32 {\n  let q = abs(position) - size;\n  return length(max(q, vec3<f32>(0.0))) + \n         min(max(q.x, max(q.y, q.z)), 0.0) - \n         radius;\n}"
        },
        {
          "name": "roundedConeSDF",
          "description": "a signed distance field for a rounded cone.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius1",
              "type": "f32",
              "description": "Bottom radius of the cone."
            },
            {
              "name": "radius2",
              "type": "f32",
              "description": "Top radius of the cone."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cone."
            },
            {
              "name": "roundness",
              "type": "f32",
              "description": "Rounding factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded cone surface."
          },
          "wgslCode": "fn roundedConeSDF(position: vec3<f32>, radius1: f32, radius2: f32, height: f32, roundness: f32) -> f32 {\n  // Calculate distances\n  let p = position;\n  let r1 = radius1 - roundness;\n  let r2 = radius2 - roundness;\n  let h = height;\n  \n  // Squared distance from axis\n  let q = length(p.xz);\n  \n  // Project into 2D space\n  let k1 = (r2 - r1) / h;\n  let k2 = h / (r1 - r2);\n  let projected = vec2<f32>(q - r1 + r1 * (p.y / h) * (r1 - r2) / r1, p.y - h);\n  let ca = p.y * k1 - q;\n  let cb = p.y - r1 * k2 + q * k2;\n  \n  var s: f32;\n  if (ca < 0.0 && projected.y < 0.0) {\n    s = length(projected) - roundness;\n  } else if (ca > 0.0 && cb < 0.0) {\n    s = -ca - roundness;\n  } else {\n    s = length(vec2<f32>(max(ca, 0.0), max(projected.y, 0.0))) - roundness;\n  }\n  \n  return s;\n}"
        },
        {
          "name": "roundedCylinderSDF",
          "description": "a signed distance field for a rounded cylinder.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the cylinder."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the cylinder."
            },
            {
              "name": "roundness",
              "type": "f32",
              "description": "Rounding factor for the edges."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the rounded cylinder surface."
          },
          "wgslCode": "fn roundedCylinderSDF(position: vec3<f32>, radius: f32, height: f32, roundness: f32) -> f32 {\n  // Calculate distances\n  let radiusOffset = radius - roundness;\n  let heightOffset = height * 0.5 - roundness;\n  \n  // Generate rounded cylinder\n  let d = vec2<f32>(length(position.xz) - radiusOffset, abs(position.y) - heightOffset);\n  return min(max(d.x, d.y), 0.0) + length(max(d, vec2<f32>(0.0))) - roundness;\n}"
        },
        {
          "name": "sphereSDF",
          "description": "a signed distance field for a sphere.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the sphere."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the sphere surface."
          },
          "wgslCode": "fn sphereSDF(position: vec3<f32>, radius: f32) -> f32 {\n  return length(position) - radius;\n}"
        },
        {
          "name": "tetrahedronSDF",
          "description": "a signed distance field for a tetrahedron.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "size",
              "type": "f32",
              "description": "Size of the tetrahedron."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the tetrahedron surface."
          },
          "wgslCode": "fn tetrahedronSDF(position: vec3<f32>, size: f32) -> f32 {\n  var p = position;\n  let s = size;\n  \n  // Set initial values\n  let signVal = sign(p.x + p.y + p.z);\n  p.x = abs(p.x);\n  p.y = abs(p.y);\n  p.z = abs(p.z);\n  \n  // Calculate the distance\n  if (p.x < p.y) {\n    let t = p.x;\n    p.x = p.y;\n    p.y = t;\n  }\n  if (p.x < p.z) {\n    let t = p.x;\n    p.x = p.z;\n    p.z = t;\n  }\n  if (p.y < p.z) {\n    let t = p.y;\n    p.y = p.z;\n    p.z = t;\n  }\n  \n  let k = clamp((p.x + p.z - p.y) * 0.5, 0.0, p.z);\n  return signVal * (length(vec3<f32>(p.x, p.y - s, p.z - k)) - s);\n}"
        },
        {
          "name": "torusSDF",
          "description": "a signed distance field for a torus.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "majorRadius",
              "type": "f32",
              "description": "Major radius of the torus."
            },
            {
              "name": "minorRadius",
              "type": "f32",
              "description": "Minor radius of the torus."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the torus surface."
          },
          "wgslCode": "fn torusSDF(position: vec3<f32>, majorRadius: f32, minorRadius: f32) -> f32 {\n  let q = vec2<f32>(length(position.xz) - majorRadius, position.y);\n  return length(q) - minorRadius;\n}"
        },
        {
          "name": "triangularPrismSDF",
          "description": "a signed distance field for a triangular prism.",
          "params": [
            {
              "name": "position",
              "type": "vec3<f32>",
              "description": "3D position to evaluate."
            },
            {
              "name": "radius",
              "type": "f32",
              "description": "Radius of the triangular base."
            },
            {
              "name": "height",
              "type": "f32",
              "description": "Height of the prism."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "distance to the triangular prism surface."
          },
          "wgslCode": "fn triangularPrismSDF(position: vec3<f32>, radius: f32, height: f32) -> f32 {\n  var q = abs(position);\n  \n  // Triangle distance in xy-plane\n  let k = sqrt(3.0);\n  q.x = abs(q.x - q.y * k * 0.5);\n  q.y = q.y * 0.866025404 + q.x * 0.5;\n  \n  // Combine with z distance\n  let d1 = vec2<f32>(q.x - radius, q.y);\n  let d2 = vec2<f32>(q.y - radius, q.x);\n  let d = min(d1, d2);\n  \n  // Account for height\n  let h = height * 0.5;\n  let dz = q.z - h;\n  let dz2 = max(dz, 0.0);\n  \n  return length(max(vec2<f32>(max(d.x, 0.0), dz2), vec2<f32>(0.0))) + min(max(d.x, dz), 0.0);\n}"
        }
      ]
    },
    {
      "name": "Color & Graphics",
      "slug": "color---graphics",
      "description": "Color space conversion and palette generation functions.",
      "functions": [
        {
          "name": "palette",
          "description": "colors using cosine-based palette function for smooth color gradients.",
          "params": [
            {
              "name": "t",
              "type": "f32",
              "description": "Input parameter (typically 0-1) for palette lookup."
            },
            {
              "name": "a",
              "type": "vec3<f32>",
              "description": "Offset values for RGB channels."
            },
            {
              "name": "b",
              "type": "vec3<f32>",
              "description": "Amplitude values for RGB channels."
            },
            {
              "name": "c",
              "type": "vec3<f32>",
              "description": "Frequency values for RGB channels."
            },
            {
              "name": "d",
              "type": "vec3<f32>",
              "description": "Phase values for RGB channels."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "RGB color."
          },
          "wgslCode": "fn palette(t: f32, a: vec3<f32>, b: vec3<f32>, c: vec3<f32>, d: vec3<f32>) -> vec3<f32> {\n  return a + b * cos(6.28318 * (c * t + d));\n}"
        },
        {
          "name": "linearToSrgb",
          "description": "linear RGB color values to sRGB color space.",
          "params": [
            {
              "name": "color",
              "type": "vec3<f32>",
              "description": "Linear RGB color values."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "color values."
          },
          "wgslCode": "fn linearToSrgb(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3(1.0 / 2.2));\n}"
        },
        {
          "name": "srgbToLinear",
          "description": "sRGB color values to linear RGB color space.",
          "params": [
            {
              "name": "color",
              "type": "vec3<f32>",
              "description": "sRGB color values."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "RGB color values."
          },
          "wgslCode": "fn srgbToLinear(color: vec3<f32>) -> vec3<f32> {\n  return pow(color, vec3(2.2));\n}"
        },
        {
          "name": "hue2rgb",
          "description": "function for HSL to RGB conversion - converts hue component to RGB.",
          "params": [
            {
              "name": "p",
              "type": "f32",
              "description": "First HSL conversion parameter."
            },
            {
              "name": "q",
              "type": "f32",
              "description": "Second HSL conversion parameter."
            },
            {
              "name": "t",
              "type": "f32",
              "description": "Hue value (adjusted)."
            }
          ],
          "returns": {
            "type": "f32",
            "description": "component value."
          },
          "wgslCode": "fn hue2rgb(p: f32, q: f32, t: f32) -> f32 {\n  var t_adj = t;\n  if (t_adj < 0.0) { t_adj += 1.0; }\n  if (t_adj > 1.0) { t_adj -= 1.0; }\n  if (t_adj < 1.0 / 6.0) { return p + (q - p) * 6.0 * t_adj; }\n  if (t_adj < 1.0 / 2.0) { return q; }\n  if (t_adj < 2.0 / 3.0) { return p + (q - p) * (2.0 / 3.0 - t_adj) * 6.0; }\n  return p;\n}"
        },
        {
          "name": "hslToRgb",
          "description": "HSL (Hue, Saturation, Lightness) color to RGB.",
          "params": [
            {
              "name": "hsl",
              "type": "vec3<f32>",
              "description": "HSL color values (hue: 0-1, saturation: 0-1, lightness: 0-1)."
            }
          ],
          "returns": {
            "type": "vec3<f32>",
            "description": "color values."
          },
          "wgslCode": "fn hslToRgb(hsl: vec3<f32>) -> vec3<f32> {\n  let h = hsl.x;\n  let s = hsl.y;\n  let l = hsl.z;\n  \n  if (s == 0.0) {\n    return vec3(l); // achromatic\n  }\n  \n  let q = select(l * (1.0 + s), l + s - l * s, l < 0.5);\n  let p = 2.0 * l - q;\n  \n  return vec3(\n    hue2rgb(p, q, h + 1.0 / 3.0),\n    hue2rgb(p, q, h),\n    hue2rgb(p, q, h - 1.0 / 3.0)\n  );\n}"
        }
      ]
    }
  ]
}